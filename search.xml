<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《java web开发与应用》笔记（编辑中）]]></title>
    <url>%2F2018%2F12%2F17%2F%E3%80%8Ajava%20web%E5%BC%80%E5%8F%91%E4%B8%8E%E5%BA%94%E7%94%A8%E3%80%8B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[从C/S从到B/SCS比如qq的电脑端，比如京东网页版◆问答问:C/S有哪些不足?一答:在C/S模式下,客户端程序带有丰富的功能,网络上传递的一般只是数据本身,客户端收到数据之后,负责处理这些数据并进行显示。功能稍有改动,必须通知客户端更新。如何解决这个间题?解决办法实际上很简单:让界面的显示效果在服务器端生成,传给客户端;服务器传什么,客户端就显示什么,客户端不要参与太多数据处理。这样,管理员如果想内容修改了,也不需要通知客户端升级,客户端只需要安装负责显示的软件,就可以了。有两种技术可以解决以上问题。1.以HTML为代表的界面表达技术。2.以浏览器为代表的界面显示软件。以上思想的实现,就是B/S模式。B/S(浏览器/服务器),也分为客户机和服务器两层,但是客户机上不用安装软件,只需要使用浏览器即可,网络上传输的也不再是普通数据,而是将这些数据用HTML等技术进行处理之后的结果。而Web网站最基本的要求是:必须使客户能够通过HTTP访问网站中的网页。比如,输人ht://www.google.com,可以打开Google页面,说明Google就是Web网站。怎样让用户能通过HTTP访问网页呢?很简单,只需将网页放在服务器中运行。当然,此处所讲的服务器是软件服务器（比如Tomcat）,不是硬件服务器。 Cookie原理Cookie它能够使客户在登录过程中摆脱烦琐的输入账号和密码的过程。 Cookie的原理如下(1)当用户登录成功后,服务器将其登录信息(如账号、密码)保存在客户端硬盘上的一个小文件内。(2)下次用户访问该网站,浏览器读取该小文件(即 Cookie)中的信息(如账号、密码)传给服务器。(3)服务器对这些信息进行验证,如果验证通过,跳转到登录成功的页面Cookie翻译成中文是“小甜饼”的意思。φ特别提醒在某台特定的计算机(如家里的计算机)上选中“在1个月之内保存登录状态”,下次登录不需要输入账号、密码,并不代表账号、密码不需要在服务器端验证 MVC思想你做好了一个学校教务系统。有一天，学校突然决定,选课表单显示应该更美观一些,要改变显示方法°由于计算机犯罪越来越多,要求在验证信息的时候多一些功能,如安全密钥等数据库迁移,数据库变成了不同的名字,表结构也改变了,查询时需要修改代码。如果使用以上方案,要解决这些问题,就必须把JSP的某一部分改掉。但是,编写代码时最忌讳的就是在很长的一段程序中修改很小的一部分,这样做代价很高,并且在开发过程中分工也很不方便。如:美工人员修改显示方法时,需要面对大量数据库访问代码。因此,该方案中,将页面设计和商业逻辑混合在一起,在修改时必须读懂所有代码。从网页编写者的角度讲，希望看到的是大量的标签而不是java。而编程人员不需要知道数据库的结构，开发时便于分工。基于该问题,可以将该JSP拆成三个模块来实现。首先,编写JSP,负责输入查询代码,提交到 Servlet, Servlet进行安全验证,调用DAO来访问数据库,得到结果,跳转到JSP显示这种方法,虽然前期设计比较复杂,但有如下特点适合分工,每一个程序员只需要关心他自己所需要关心的那个模块。维护方便,比如需要修改其中的一个部分,就对相应的模块进行修改就可以了。对比这两种方案,可以发现,第二种方案把程序分为不同的模块,显示、业务逻辑、过程控制都独立起来,使得软件在可伸缩性和可维护性方面有了很大的优势。如要改变外观显示,只需要修改JSP就可以了;修改验证方法,只需要修改 Servlet就可以了;数据库迁移,只需要修改DAO就可以了。这种思想就是MVC思想。 request.getParameter不仅可以获取文本框数据，可以获取单选、双选、下拉菜单数据多选1234567891011121314唱歌&lt;input name=&quot;fav&quot; type=&quot;checkbox&quot; value=&quot;singing&quot;&gt;跳舞&lt;input name=&quot;fav&quot; type=&quot;checkbox&quot; value=&quot;dance&quot;&gt;打球&lt;input name=&quot;fav&quot; type=&quot;checkbox&quot; value=&quot;ball&quot;&gt;打游戏&lt;input name=&quot;fav&quot; type=&quot;checkbox&quot; value=&quot;game&quot;&gt;获取数据代码:&lt;%String [] fav=request.getParameterValues(&quot;fav&quot;); for (String s : fav) &#123; %&gt;&lt;%=s%&gt;&lt;% &#125;%&gt; 单选123性别： 男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;boy&quot; &gt; 女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;girl&quot;&gt; 获取数据代码略 下拉菜单12345&lt;select name=&quot;home&quot;&gt; &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;&quot;&gt;广州&lt;/option&gt;&lt;/select&gt; 获取数据代码略 jsp有些功能用 JavaScript也能够实现,那有何区别?答:最大的区别是, Java Script源代码是被服务器发送到客户端,由客户端执行,因此,客户端可以看到 JavaScript源代码;而Java代码却不会。也就是说，你在开发者工具中是中是看不到jsp页面中的Java代码的。 为什么需要url传值？比如教务系统中，每个学生信息后面的删除按钮。点击之后会跳转到删除操作页面。但如何知道要删除哪个学生呢？这就需要在url跳转的时候顺便把要删除的学生学号传过去。当然，也可以传给本页面。删除删除再比如说，页面上有10个链接，分别是1 2 3 4 5 6 7 8 9 10，单击相应的链接，在底部打印相应的乘法表。如点击4打印四四乘法表。如果传值是中文会出现乱码问题，传值和取值以前分别进行编码和解码URLEncoder.encode()；和URLEncoder.decode() 为什么需要include指令？版权信息你不可能每个页面每个页面的复制吧，如果有变动岂不是每个都要改？ include指令和include动作的区别&lt;%@include file=”info.jsp”%&gt;include指令不会实时更新&lt;jsp:include page=”info.jsp” /&gt;include动作会实时更新include指令在JSP编译时就将对应的文件包含进来。而 include动作则不同,其会在客户端对JSP文件发出请求的时候将对应包含文件的输出包含进来。include动作还会自动检查被包含文件的变化。也就是说,当被包含资源的内容发生变化的时候,使用 include指令的话,服务器可能不会检测到,所以不会对其进行重新的编译,这给维护带来了巨大的麻烦。include动作则可以在每次客户端发出请求时重新把资源包含进来,进行实时的更新。 其他URL传值会在浏览器的地址栏中看到传递的信息;隐藏表单会在客户端页面的源代码中看到传递的信息;Cookie会在客户端页面的文本文件中看到传递的信息。 如何在线修改学生名字？其实是根据主键学号修改。可以通过隐藏input学号信息。点击修改时传学号过去实现。 检查用户提交的信息是否为空，可以用javascript实现 jsp内置对象是自动载入的，因此它们不需要直接实例化 请求服务器的端口号的方法可以做类似：检查IP以220开头的用户是非法用户 如何检查用户输入是否有非法字符：用循环获得所有表单数据 web.xml设置欢迎页 servlet为了实现控制者这一角色，必须要能够实现跳转 过滤器可以判断用户类型，管理员、普通用户]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java框架]]></title>
    <url>%2F2018%2F10%2F14%2F%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[javabean1.这个Java类必须具有一个无参的构造函数2.属性必须私有化。3.私有化的属性必须通过public类型的方法暴露给其它程序，并且方法的命名也必须遵守一定的命名规范。 HibernateProduct.hbm.xml文件作用是将javabean对应数据库中的表1234567891011121314151617&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt; &lt;hibernate-mapping package=&quot;com.how2java.pojo&quot;&gt; &lt;class name=&quot;Product&quot; table=&quot;product_&quot;&gt;//表示类Product对应表product_ &lt;id name=&quot;id&quot; column=&quot;id&quot;&gt;//表示属性id,映射表里的字段id &lt;generator class=&quot;native&quot;&gt;//意味着id的自增长方式采用数据库的本地方式 &lt;/generator&gt; &lt;/id&gt; &lt;property name=&quot;name&quot; /&gt;//这里没有通过column=&quot;name&quot; 显式的指定字段），因为属性和字段同名 &lt;property name=&quot;price&quot; /&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; hibernate.cfg.xml文件访问数据库配置。注意，这个文件要放在src目录下12345678910111213141516171819202122&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;&quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt; &lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- Database connection settings --&gt; &lt;property name=&quot;connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;connection.url&quot;&gt;jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8&lt;/property&gt;//这表示使用MYSQL方言 &lt;property name=&quot;connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;connection.password&quot;&gt;admin&lt;/property&gt; &lt;!-- SQL dialect --&gt; &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;property name=&quot;current_session_context_class&quot;&gt;thread&lt;/property&gt; &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt;//这表示是否在控制台显示执行的sql语句 &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt;//这表示是否会自动更新数据库的表结构，有这句话Hibernate会自动去创建表结构 &lt;mapping resource=&quot;com/how2java/pojo/Product.hbm.xml&quot; /&gt;//识别Product这个实体类 &lt;/session-factory&gt; &lt;/hibernate-configuration&gt; 测试类hibernate的基本步骤是： 获取SessionFactory 通过SessionFactory 获取一个Session 在Session基础上开启一个事务 通过调用Session的save方法把对象保存到数据库 提交事务 关闭Session 关闭SessionFactory12345678910111213SessionFactory sf = new Configuration().configure().buildSessionFactory();//1.获取SessionFactorySession s = sf.openSession();//2.通过SessionFactory 获取一个Sessions.beginTransaction();//3.在Session基础上开启一个事务Product p = new Product();p.setName(&quot;iphone7&quot;);p.setPrice(7000);s.save(p);//4. 通过调用Session的save方法把对象保存到数据库s.getTransaction().commit();//5. 提交事务s.close();//6. 关闭Sessionsf.close();//7. 关闭SessionFactory]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java web]]></title>
    <url>%2F2018%2F10%2F14%2Fjavaweb%2F</url>
    <content type="text"><![CDATA[servlet写一个servlet第一步：html表单提交请求&lt;form action=&quot;login&quot; method=&quot;post&quot;&gt; 第二步：servlet类中的请求处理12public class LoginServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) 第三步：配置web.xml12345678&lt;servlet-name&gt;L1&lt;/servlet-name&gt;//类的缩写 &lt;servlet-class&gt;Myservlet.LoginServlet&lt;/servlet-class&gt;//类的名称&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;L1&lt;/servlet-name&gt;//类的缩写，和上面一致就行 &lt;url-pattern&gt;/login&lt;/url-pattern&gt;//映射为的url地址，注意有“/”。对应&lt;form action=&quot;login&quot;&lt;/servlet-mapping&gt; 处理请求的三种方法1、dopost、doget、servicedoget：是默认方法，比如超链访问、地址栏直接输入某个地址。特点：1.不安全，提交数据会在浏览器地址栏显示出来2.不可以上传文件3.有大小的限制 dopost：一般用于注册、修改请求特点：1.安全2.可以上传文件3.没有限制 request和reponse常用方法requestrequest.getParameter(): 是常见的方法，用于获取单值的参数request.getParameterValues(): 用于获取具有多值得参数，比如注册的时候提交的爱好，可以使多选的。request.getParameterMap(): 用于遍历所有的参数，并返回Map类型。 request.getRequestURL(): 浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)” +request.getRequestURI(): 浏览器发出请求的资源名部分，去掉了协议和主机名” +request.getQueryString(): 请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到request.getRemoteAddr(): 浏览器所处于的客户机的IP地址request.getRemoteHost(): 浏览器所处于的客户机的主机名request.getRemotePort(): 浏览器所处于的客户机使用的网络端口request.getLocalAddr(): 服务器的IP地址request.getLocalName(): 服务器的主机名request.getMethod(): 得到客户机请求方式一般是GET或者POST request.getHeader() 获取浏览器传递过来的头信息。比如getHeader(“user-agent”) 可以获取浏览器的基本资料，这样就能判断是firefox、IE、chrome、或者是safari浏览器request.getHeaderNames() 获取浏览器所有的头信息名称，根据头信息名称就能遍历出所有的头信息 reponse(待完善)用于提供给浏览器的响应信息 服务端跳转和客户端跳转服务端跳转request.getRequestDispatcher(&quot;success.html&quot;).forward(request, response); 客户端跳转response.sendRedirect(&quot;fail.html&quot;); 区别在于客户端跳转时候浏览器地址发生了变化 中文问题获取中文参数，只需三步 login.html中加上 &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; 这句话的目的是告诉浏览器，等下发消息给服务器的时候，使用UTF-8编码 login.htmlform的method修改为post 在servlet进行解码和编码把下面这句代码放在request.getParameter()之前request.setCharacterEncoding(&quot;UTF-8&quot;);这句话的目的UTF-8解码，然后用UTF-8编码 返回中文的响应在Servlet中，加上response.setContentType(&quot;text/html; charset=UTF-8&quot;); servlet的一些概念生命周期servlet生命周期有5步：实例化，初始化，提供服务，销毁，被回收初始化：（ init(ServletConfig) 实例方法，只会执行一次）LoginSerlvet构造方法 只会执行一次，所以Serlvet是单实例的 servlet和jspjsp就是在html里面写java代码，servlet就是在java里面写html代码 jsp更注重前端显示，servlet更注重模型和业务逻辑 jsp经过容器解释之后就是一个servlet类.我们说HelloServlet是一个Servlet，不是因为它的类名里有一个”Servlet”，而是因为它继承了 HttpServlet打开转译hello.jsp 后得到的hello_jsp.java，可以发现它继承了类HttpJspBase，而HttpJspBase 继承了HttpServlet所以我们说hello_.jsp.java 是一个Servlet JSP页面元素123456789101112131415161718192021221. 静态内容就是html,css,javascript等内容2. 指令以&lt;%@开始 %&gt; 结尾，比如&lt;%@page import=&quot;java.util.*&quot;%&gt;3. 表达式 &lt;%=%&gt;4. Scriptlet在&lt;%%&gt; 之间，可以写任何java 代码5. 声明在&lt;%!%&gt; 之间可以声明字段或者方法。但是不建议这么做。6. 动作&lt;jsp:include page=&quot;Filename&quot; &gt; 在jsp页面中包含另一个页面。在包含的章节有详细的讲解7. 注释 &lt;%-- -- %&gt;不同于 html的注释 &lt;!-- --&gt; 通过jsp的注释，浏览器也看不到相应的代码，相当于在servlet中注释掉了8. 表达式用于输出一段html，比如&lt;%=&quot;hello jsp&quot;%&gt;相当于&lt;%out.println(&quot;hello jsp&quot;);%&gt;再比如&lt;%for (String word : words) &#123;%&gt;&lt;tr&gt; &lt;td&gt;&lt;%=word%&gt;&lt;/td&gt;&lt;/tr&gt;&lt;%&#125;%&gt; 九大内置对象request,response,out pageContext, session,application作用域：页面、用户、全局 page,config,exception 使用javabean session设置session.getAttribute(&quot;name&quot;);取得String name = (String)session.getAttribute(&quot;name&quot;); Cookie1234567891011121314151617//创健Cookie u= new Cookie(&quot;username&quot;,username);键，值对的关系存储`//设置生存时间u.setMaxAge(864000);`//保存 response.addCookie(u);`//把所有cookie取出来装入数组 Cookie[] cookies = request.getCookies();if(c.getName().equals(&quot;username&quot;)||c.getName().equals(&quot;password&quot;)) &#123;c.setMaxAge(0); //设置Cookie失效 response.addCookie(c); //重新保存。//取键 if(c.getName().equals(&quot;username&quot;)) //取值username = URLDecoder.decode(c.getValue(),&quot;utf-8&quot;);]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[javaSE（下）]]></title>
    <url>%2F2018%2F10%2F10%2FjavaSE%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[异常try catch finally 没啥好说的。。。 常见的runtime exception：(不是必须进行try catch的异常 )NullPointerException 空指针异常ArithmeticException 算术异常，比如除数为零ClassCastException 类型转换异常ConcurrentModificationException 同步修改异常，遍历一个集合的时候，删除集合的元素，就会抛出该异常IndexOutOfBoundsException 数组下标越界异常NegativeArraySizeException 为数组分配的空间是负数异常 throw和throws的区别举个栗子throw是语句抛出一个异常1234String s = &quot;abc&quot;; if(s.equals(&quot;abc&quot;)) &#123; throw new NumberFormatException(); &#125; throws是方法可能抛出异常的声明public static void function() throws NumberFormatException{ 集合基础概念 Java容器类类库的用途是”保存对象”，并将其划分为两个不同的概念：1) Collection一组”对立”的元素，通常这些元素都服从某种规则 1.1) List必须保持元素特定的顺序 1.2) Set不能有重复元素 1.3) Queue保持一个队列(先进先出)的顺序2) Map一组成对的”键值对”对象 Collection与CollectionsCollection是所有集合类的根接口；Collections是提供集合操作的工具类；常用方法如下reverse 反转shuffle 混淆sort 排序swap 交换（交换0和5下标的数据后）Collections.swap(numbers,0,5);rotate 滚动(把集合中的数据向右滚动2个单位) Collections.rotate(numbers,2);synchronizedList 线程安全化 常用集合ArrayList代码展示ArrayList常用方法1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; List&lt;String&gt; animal = new ArrayList&lt;String&gt;(); //增 animal.add(&quot;松鼠&quot;); animal.add(1, &quot;花猪&quot;); //删 animal.remove(0); animal.remove(&quot;花猪&quot;); //查 System.out.println(animal.get(1));//根据位置获取对象 System.out.println(animal.indexOf(&quot;松鼠&quot;));//查对象的位置 //改 animal.set(0, &quot;猫&quot;); //获取大小 System.out.println(animal.size()); //判断是否包含 System.out.println(animal.contains(&quot;小狗&quot;)); //把另一个容器所有对象都加进来 ArrayList human = new ArrayList(); animal.addAll(human); //转为数组，类型要是一样的哦 String[] array = new String[animal.size()]; animal.toArray(array);&#125; HashMapIO流多线程（待完善）]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[javaSE（上）]]></title>
    <url>%2F2018%2F10%2F08%2FjavaSE%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[变量&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 变量名起名规则 字母 数字 $ _ 组成 变量第一个字符，不能使用数字。 不可以使用关键字。 再一次提交 数据类型：八种基本类型： 整型 （4种） 字符型 （1种） 浮点型 （2种） 布尔型（1种）&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 1）：基本数据类型：byte、short、int、long、float、double、char、boolean简单类型 boolean byte char short int long float double void二进制位数 1 8 16 16 32 64 32 64 – 封装器类 Boolean Byte Character Short Integer Long Float Double基本数据类型：byte、short、int、long、float、double、char、boolean简单类型的二进制位数 boolean 1(位)， byte 8， char16， short 16， int 32， long 64， float 32， double 64 再一次提交 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 变量的范围 1.当一个变量被声明在类下面变量就叫做字段或者属性或者成员变量 2.如果一个变量，是声明在一个方法上的，就叫做参数或者局部变量 变量的范围1.当一个变量被声明在类下面变量就叫做字段或者属性或者成员变量 2.如果一个变量，是声明在一个方法上的，就叫做参数或者局部变量 再一次提交 类型转换 强制转换 12int i1 = 10;byte b = (byte) i1; 自动装箱和拆箱 12Integer i = 100; //自动装箱，编译器执行Integer.valueOf(100)int j = i; //自动拆箱，编译器执行i.intValue() ==与equals() ==比较的是两个对象的引用是否相同，或者是比较原始数据类型是否相等；equals()比较的是两个对象的内容是否相同。 题目：类型提升123456 byte b1 = 3; byte b2 = 4; byte b3 = b1 + b2; //编译错误 byte b4 = 3 + 4; //编译正确//（1）变量相加，首先首先进行类型提升，之后再进行计算，计算后将结果赋值；//（2）常量相加，首先进行计算，之后判断是否在接受类型的范围，在则赋值。 题目：扩展赋值运算符隐含强制类型转换问题 判断下列代码是否有误，并指出错误12345678 short s = 1; s = s + 1; //错误，s在参加运算时会自动提示类型为int // int类型值无法直接赋值于short类型 short z = 1; z += 1; //正确,扩展赋值运算符包含强制类型转换 //等价于 z = (short)(z + 1);其次，-128~127的Integer值可以从缓存中取得。其他情况要重新创建 题目：自增运算符的问题int i = 1;i+=++i;的运算结果？i+=++i,其中先算++i,得到2，由于++i并未进行赋值，所以i还是1，i+=2为3 循环switch12345678910111213141516171819202122232425switch(day)&#123; case 1: System.out.println(&quot;星期一&quot;); break; case 2: System.out.println(&quot;星期二&quot;); break; case 3: System.out.println(&quot;星期三&quot;); break; case 4: System.out.println(&quot;星期四&quot;); break; case 5: System.out.println(&quot;星期五&quot;); break; case 6: System.out.println(&quot;星期六&quot;); break; case 7: System.out.println(&quot;星期天&quot;); break; default: System.out.println(&quot;输入有误&quot;); &#125; 数组3种创建方式1234int[] arr1 = &#123;1,2,3,4&#125;; //正确int[] arr2 = new int[4]; //正确int[] arr3 = new int[]&#123;1,2,3,4&#125;; //正确int[] arr4 = new int[4]&#123;1,2,3,4&#125;;s //错误，编译不通过 封装、继承、多态继承 问题：为什么子类中所有的构造方法默认都会访问父类中无参的构造方法？因为子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化。其实：每一个构造方法的第一条语句默认都是：super() Object类最顶层的父类。 问题：Override(重写)和Overload(重载)的区别?Overload能改变返回值类型吗?overload可以改变返回值类型,只看参数列表方法重写：方法的重载指的是子类的方法名与父类的一样，但是参数类型不一样如果没有重写这样的机制，一旦继承了父类，所有方法都不能修改了。方法重载：本类中出现的方法名一样，参数列表不同的方法。与返回值类型无关。子类对象调用方法的时候：先找子类本身，再找父类。(就近原则) 隐藏，就是子类覆盖父类的类方法。（重写是子类覆盖父类的对象方法 ） 封装 访问修饰权限：private, default, public, protected修饰符 当前类 同一包内 子孙类 其他包 其他包子孙类public Y Y Y Y Yprotected Y Y Y N Y/N（说明）default Y Y N N Nprivate Y N N N N 不写修饰符默认用package/friendly/default修饰：既同包子类内才可访问，不同包的子类不行 属性通常使用private封装起来 方法一般使用public用于被调用 会被子类继承的方法，通常使用protected package用的不多，一般新手会用package,因为还不知道有修饰符这个东西 接口就像是一种约定一个类可以实现多个接口，但只能继承一个父类。 接口和抽象类的主要区别从概念上来说抽象类是一种对事物的抽象，而接口是一种对行为的抽象；抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。抽象类是一种模板式设计，而接口是一种行为规范，是一种辐射式设计。 模板式设计：如果B和C都使用了公共模板A，如果他们的公共部分需要改动，那么只改动A就可以了；辐射式设计：如果B和C都实现了公共接口A，如果现在要向A中添加新的方法，那么B和C都必须进行相应改动。 区别1：子类只能继承一个抽象类，不能继承多个子类可以实现多个接口 区别2：抽象类可以定义public,protected,package,private、静态和非静态属性、final和非final属性但是接口中声明的属性，只能是public、静态、final的 多态 操作符的多态加号+可以作为算数运算，也可以作为字符串连接。不同情境下，具备不同的作用如果+号两侧都是整型，那么+代表数字相加如果+号两侧，任意一个是字符串，那么+代表字符串连接 类的多态 父类的引用指向子类的对象，子类的方法重写代码：Employee e=new Manager();不过如果Employee类没有定义abc()，而Manager类定义abc()，如果调用e.abc()则编译不通过。 其他this关键字1234567891011121314151617//参数名和属性名一样 //在方法体中，只能访问到参数name public void setName1(String name)&#123; name = name; &#125; //为了避免setName1中的问题，参数名不得不使用其他变量名 public void setName2(String heroName)&#123; name = heroName; &#125; //通过this访问属性 public void setName3(String name)&#123; //name代表的是参数name //this.name代表的是属性name this.name = name; &#125; 对象属性初始化方法有3种 声明该属性的时候初始化 构造方法中初始化 初始化块如果同时初始化同一变量，则优先级是：构造方法中初始化&gt;初始化块&gt; 声明该属性的时候初始化 关键字 final修饰变量时，用以定义常量；修饰方法时，方法不能被重写（Override）；修饰类时，类不能被继承。 枚举123456789101112131415161718192021public enum Season &#123;//是枚举enum不是类class SPRING, SUMMER, AUTUMN, WINTER;//直接这样写 public static void main(String[] args) &#123; Season season = Season.SPRING; switch (season) &#123; case SPRING: System.out.println(&quot;春天&quot;); break; case SUMMER: System.out.println(&quot;夏天&quot;); break; case AUTUMN: System.out.println(&quot;秋天&quot;); break; case WINTER: System.out.println(&quot;冬天&quot;); break; &#125; &#125; &#125; 模式单例模式（重要）单例模式的三元素 构造方法私有化 静态属性指向实例 public static的 getInstance方法，返回第二步的静态属性（日历Calendar类就是一个单例模式） 单例模式分为两种：饿汉和懒汉 1.饿汉单例模式：无论如何都会创建一个实例class GiantDragon &#123;12345678910111213141516171819 //私有化构造方法使得该类无法在外部通过new 进行实例化 private GiantDragon()&#123; &#125; //准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个 private static GiantDragon instance = new GiantDragon(); //public static 方法，提供给调用者获取12行定义的对象 public static GiantDragon getInstance()&#123; return instance; &#125; public static void main(String[] args) &#123; GiantDragon g1 = GiantDragon.getInstance(); &#125; &#125; 懒汉单例模式只：有在调用getInstance的时候，才会创建实例class GiantDragon &#123;12345678910111213141516171819202122 //私有化构造方法使得该类无法在外部通过new 进行实例化 private GiantDragon()&#123; &#125; //准备一个类属性，用于指向一个实例化对象，但是暂时指向null private static GiantDragon instance; //public static 方法，返回实例对象 public static GiantDragon getInstance()&#123; //第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象 if(null==instance)&#123; instance = new GiantDragon(); &#125; //返回 instance指向的对象 return instance; &#125; public static void main(String[] args) &#123; GiantDragon g2 = GiantDragon.getInstance(); &#125; &#125; 内部类（待完善）内部类分为四种：非静态内部类静态内部类匿名类本地类 字符串字符串常用方法见截图 格式化%s 表示字符串%d 表示数字%n 表示换行1234567String name =&quot;盖伦&quot;;int kill = 8;String title=&quot;超神&quot;; String sentenceFormat =&quot;%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n&quot;;//使用printf格式化输出System.out.printf(sentenceFormat,name,kill,title);//第一个是原字符串 字符串的转化数字与字符串 数字转字符串方法1： 使用String类的静态方法valueOfString str = String.valueOf(i); 方法2： 先把基本类型装箱为对象，然后调用对象的toStringInteger it = i;String str2 = it.toString(); 字符串转数字String str = “999”;int i= Integer.parseInt(str); 字符串与字符串数组 字符数组 转 字符串char[] data={‘a’,’b’,’c’};String s=new String(data); 字符串数组转换成字符串，只能通过循环赋值，没有其他方法 s1.charAt(0)=c1;是不行的s1.charAt(0);是可以的 时间格式化时间时间（注意月和小时是大写的喔） y 代表年M 代表月d 代表日H 代表24进制的小时h 代表12进制的小时m 代表分钟s 代表秒S 代表毫秒12345Date d = new Date();System.out.println(d);//输出当前时间SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日,HH时mm分ss秒&quot;);//设置样式String s = sdf.format(d);//把d这个时间实例格式化，并且赋值给字符串sSystem.out.println(s);//输出的字符串s就是格式化好的时间啦 日历（可以做“查看明年的今天是几号”之类的事）123456789101112Calendar c = Calendar.getInstance();//Calendar用单例模式创造实例Date now = c.getTime();c.setTime(now);//先翻到下下个月c.add(Calendar.MONTH,2);//设置到月初c.set(Calendar.DATE,1);//再往回翻3天c.add(Calendar.DATE,-3);System.out.println(&quot;下个月的倒数第3天是哪天&quot;+s);]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS]]></title>
    <url>%2F2018%2F09%2F18%2Fcss%2F</url>
    <content type="text"><![CDATA[css的三种写处内联式style=&quot;color:red;&quot; 嵌入式123&lt;style&gt;&lt;/style&gt; 外部式css外部式&lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot;&gt; js外部式&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt; 优先级：内联式 &gt; 嵌入式 &gt; 外部式其实总结来说，就是–就近原则（离被设置元素越近优先级别越高）。 选择器1234567891011p&#123; color:red;&#125;/*元素选择器*/#p1&#123;color:blue;&#125;/*id选择器*/.after&#123;color:green; &#125;/*类选择器*/*&#123;color:red;&#125;/*通用选择器*/a:hover&#123;color:red;&#125;/*伪类选择器*/ h1,span&#123;color:red;&#125;/*两个都*/ 选择官方参考手册http://www.w3school.com.cn/cssref/css_selectors.asp !important 注意要写在分号的前面，比如a:hover{color:red!important;}/ 布局这个慕课老师发了许多关于布局的课程，其中一些给人启发http://www.imooc.com/t/197450 一、基本知识 块级元素特点：1.一个块级元素独占一行2.元素的高度、宽度、行高以及顶和底边距都可设置。常用的块状元素有：&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;、&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt; 内联元素特点：1.和其他元素都在一行上。2.元素的高度、宽度及顶部和底部边距不可设置；常用的内联元素有：&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt; inline-block 元素特点：1、和其他元素都在一行上；2、元素的高度、宽度、行高以及顶和底边距都可设置。 display:block – 显示为块级元素display:inline – 显示为内联元素display:inline-block – 显示为内联块元素，表现为同行显示并可修改宽高内外边距等属性 tips：常将元素加上display:inline-block样式，原本垂直的列表就可以水平显示了。 二、定位float浮动定位float的设计初衷仅仅是-文字环绕效果属性有left、right、none positioinrelative相对定位：相对于它的初始位置而言移动。不可层叠。absolute绝对定位：相对于最近的已定位的父元素。可层叠。fixed悬浮定位：本质和absolute一样，不过不随浏览器滚动条向上或向下移动。 三、盒模型元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。 四、布局模型 1、流动模型（Flow） 2、浮动模型 (Float) float的设计初衷仅仅是-文字环绕效果 3、层模型（Layer） 静态网页常用代码1.如何将网页整体居中？ 方法一将整个网页放在一个大div容器下，容器设置margin和具体宽度。&lt;div style=&quot;margin: 0 auto;width:1000px;&quot;&gt;解释：上下边距为0，左右边距为自适应。 方法二1.定义大div的宽度 2.把容器position睡醒设置为relative 3.把left属性设置为50%&lt;div style=&quot;width:1000px;position:relative;left:50%;&quot;&gt; 2.如何消除默认样式？2.&lt;body style=&quot;margin:0;padding:0;&quot;&gt; 3.如何隐藏滚动条？ 方法一html { overflow-y: scroll; } 原理：强制显示ie的垂直滚动条，而忽略水平滚动条 优点：完全解决了这个问题, 允许你保持完整的XHTML doctype. 缺点：即使页面不需要垂直滚动条的时候也会出现垂直滚动条。 方法2:html { overflow-x: hidden; overflow-y: auto; } 原理：隐藏横向滚动，垂直滚动根据内容自适应 优点：在视觉上解决了这个问题.在不必要的时候, 未强制垂直滚动条出现. 缺点：只是隐藏了水平滚动条，如果页面真正需要水平滚动条的时候， 屏幕以外的内容会因为用户无法水平滚动，而看不到。 4.常用代码，搁这了，方便复制。 清除一些默认样式 1234567*&#123;margin:0;padding:0;&#125;body&#123;font-size:12px;&#125;img&#123;border:none;&#125;li&#123;list-style:none;&#125;input,select,textarea&#123;outline:none;&#125;textarea&#123;resize:none;&#125;a&#123;text-decoration:none;&#125; 刚开始肯定就是刷刷几个div包起来 123&lt;div class=&quot;&quot;&gt;&lt;/div&gt;&lt;div class=&quot;&quot;&gt;&lt;/div&gt;&lt;div class=&quot;&quot;&gt;&lt;/div&gt; Bootstrap框架引用代码 123&lt;script src=&quot;http://how2j.cn/study/js/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;http://how2j.cn/study/css/bootstrap/3.3.6/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;script src=&quot;http://how2j.cn/study/js/bootstrap/3.3.6/bootstrap.min.js&quot;&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构读书笔记]]></title>
    <url>%2F2018%2F09%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言废话：这篇笔记尽量写的没看过这本书的也能看，段落根据我认为重要程度排名。书是从学校图书馆借的，豆瓣评分寥寥，但我觉得海星鸭 p84为什么要给自己给一个类写clone的方法？而不是直接调用父类的复制方法。举个栗子，把数组a拷贝到副本b。如果直接去调用父类的复制方法。它会做什么呢？它会把b的引用都指向数组a，也就是说它并没有真正意义上的复制，而是偷懒把新引用指向原本的数组。这样做有什么问题呢？问题在于对a数组修改都会影响到拷贝的副本b。显然这不是我们想要的。所以我们得自己写一个clone类，循环遍历数组，挨个复制。笔记：大家都知道集合有length（）方法，不需要知道怎么实现，只要能用就行了。但当我们自己去写一个集合类的时候，写这个方法就必须要考虑到方方面面了。这本书重点不在于告诉人java有多少个API，而是这些类、方法的实现原理。只有当我们去重写的时候才会深度去思考程序的设计的原理。比如得知数组的长度，那么写属性size就行了，因为数组是固定长度的。但是要得知集合的长度，需要写一个方法遍历得知，因为集合是自动增长的。 p8final变量即这个变量是最终版本，不可变更，不能被继承。另外final变量的名称全部大写 。比如一个常量-273。如果把它写成final变量,则是final MINMUM_CELSIUS=-273。什么时候用常量？如果直接写c&lt;-273，那么阅读程序的人会在这里停住，直到想起-273是最小摄氏度为止。当然了，有些众所周知的公式，其原始形式更易识别。 用static修饰的话，即使没有生成该对象的实例，也可使用该方法。毕竟如果只是想使用该方法，也没有必要生成一个实例。比如java自带Math类，没有生成实例也可以直接用它生成random随机数的方法 。(Math.random() * 100)。这条语句是意思是生成一个一百以内的随机数。如果没有用static修饰，绝对不能激活空引用的方法。绝不能访问null引用的实例变量。两种情况下都会引发nullpointerexception异常。 变量分引用变量和普通变量。除了八种基本类型之一的任何变量，其余都是引向某一对象的引用变量。引用变量：有些为了省事的程序员用“油门对象t正在工作”，而不使用，“t引用的油门对象正在工作”笔记：t不是这个油门对象的命名而是这个油门对象的引用。 p49关于取名。名字最好是描述性的词存取方法：is+形容词，比如“isOn”；to+，比如“toString”；get+，比如”getFlow”修改方法：动词有返回值的静态方法：名词 如果方法需要返回多个信息，那么返回数组是一个有效的手段。 集合类不用定义容量，每当包要满时，方法就会实现，使得容量翻倍。m*2+1。加1是为了使得即使容量为零，这一动作仍能起作用。 如果没有指定修饰符，则为默认访问，也叫包访问。可以访问同一个一个包的类。 递归不只是尾递归。 java的易移植性：程序变成字节码，这些字节码由jar运行时环境编译，jar可以免费获得，所以程序可以在不同的机器间进行移植。 每一个方法有参数，前置条件，返回值。前置条件比如参数c&gt;-273。 接口代码单词一般以-able为后缀。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《华杉讲透孙子兵法》]]></title>
    <url>%2F2018%2F09%2F08%2F%E3%80%8A%E5%8D%8E%E6%9D%89%E8%AE%B2%E9%80%8F%E5%AD%99%E5%AD%90%E5%85%B5%E6%B3%95%E3%80%8B%2F</url>
    <content type="text"><![CDATA[孙子兵法再神也毕竟是几千年前写的了。这本书是借孙子兵法讲现代的公司管理，商战。最重要的是，他讲的是正确的、有道理。 实力是最厉害的计谋 1、“孙子兵法不是战法，是不战之法；不是战胜之法，是不战而胜之法；不是战而后胜之法，是先胜而后战之法。”2、 “开炮的时候，胜负已定了。”3、“打胜仗的军队，总是先获得胜利地位，获得取胜条件之后，才投入战斗。而打败仗的军队，总是冲上去就打，企图在战斗中捕捉机会侥幸获胜”4、“作战就那一下子，我们99%的工作，都是准备工作。这个道理太深了。人们容易看到的是战利品的多少得失，时间、资源的分配，总是向收割倾斜，不是向准备倾斜。 只问耕耘，不问收获。我看到有的企业家，把收获的工作交给经理人，因为今天的收获都是他三年前耕耘下的。他把他的精力和关注点，投入新的耕耘，为未来作准备” 5、“”这在管理学上叫“沉默的证据”，真正的绝大多数，绝对的大概率事件，都沉默无言，所以你不知道。而那些小概率事件，以少击多居然打赢的，人人都替他大肆宣扬，一千年后你还知道，三千年的例子累积起来，倒显得比比皆是成了主流了。6、“我们经营也是一样，你踏踏实实把产品，把服务做好，别老想着有什么“招”。实际上，奇谋诡道很容易，就那几招，其实技术含量很低，主要技术要点在于演戏要演得像而已。但是“五事七计”技术含量就太高了，全是真功夫，是人格，是智慧，是汗水，是时间，是积累。所以人们爱听三十六计，不爱听“五事七计”。7、“关羽是典型的百战百胜，一败而亡。《孙子兵法》说，真正的善战者，无智名，无勇功，因为善战者不打那么多仗，只打容易的仗，不打跌宕起伏的仗，没有那么多可歌可泣的故事。故事都是讲给老百姓听的，关羽则恰恰和孙子的胜将标准相反，他威名赫赫，在民间是集道德、智慧、武功于一身的千古第一人，而在专业人士看来，关羽实误国之臣也。”8、第二个观念，胜可知而不可为。探查敌我，便知道有没有胜算。如果没有胜算，你想上了战场再强取其胜，那是不可为。因为敌人也是身经百战，不是我们喊几句口号就能打败了。更何况口号人家也没比我们少喊。9、什么叫竞争？竞争的本质是要你没法跟我争 赏罚分明 赏无度，则费而无恩；罚无度，则戮而无威。 杜牧注得准确：“信者，使人不惑于刑赏也。”信，就是赏罚分明，每个人都非常清楚，犯什么错受什么刑，立什么功受什么赏。 所以“赏其先得者”，就是夺得第一辆战车的士卒。因为先得者，往往是倡谋者。他先发动，大家才跟着一哄而上 贾林注解说：“专任智则贼，遍施仁则懦，固守信则愚，恃勇力则暴，令过严则残。五者兼备，各适其用，方可为将帅。” 准备 绝大部分准备，都是“白准备”，因为准备本来就是“不防一万，只防万一”的，所以每一次有效准备背后，都有九千九百九十九次“白准备”。左史并非料事如神，料定吴军一定会来，他只是按操作规程，做好准备。吴军若不来，士兵们怨声载道，这事过去了，不会写进史书里，我们也不知道。吴军来了，他就名垂青史了。两千多年后我们还能知道这事，可见这样的事是很少发生那开始时下着大雨，楚军列阵等着，吴军不来怎么办？那不白准备了吗？我们经常听见人说：“我白准备了，白浪费了。”这个观念就是兵法要反对的。《兵法百言》：“宁使我有虚防，无使彼得实尝。”宁可我白准备，也不能让他万一来了，让他得手。 判断 对敌人呢，就像李世民说的，观古今兵法，就一句话：“多方以误之。”想方设法引他失误。 兵法都很简单，难的是判断。比如那敌军来，你怎么知道他是来骚扰的，还是来总攻的呢？实际上我们无法知道。所以，毛泽东说：“一上战场，兵法全忘了。”随时有紧急情况要你处理决策，哪顾得上兵法。 怎么办，就要胸中有全局，是你调动敌人，不是敌人调动你。 方不上当，不失误，怎么办呢？等待，跟他熬，派间谍，各种布置安排。总之，一定要等到平衡打破，胜算已见，才能出战。 夫霸天下者有三戒：毋贪，毋忿，毋急。贪则多失，忿则多难，急则多蹶。夫审大小而图之，乌用贪？衡彼己而施之，乌用忿？酌缓急而布之，乌用急？君能戒此三者，于霸也近矣。” 这三件事，背景、形势，都差不多，处理各有参差，结果也不同。所以处大事，决大疑，要熟思是非，不要拘于往事成败，不可迁就一时之利害，更不可归罪于谋臣 曾国藩专门说过领导者要独立承担决策责任的问题。因为成败无定，不光是定计的问题。 那么，当你认为有几分把握的时候，先自己减去三分一厢情愿分，再想想。 当我们觉得有十分把握的时候，减去三分就是七分。假如我们的判断是准确的，那就有50%的概率获胜，那赢面已经非常大了。 环境 不能“成功了都是自己伟大，失败了那是环境变化”。环境本来没义务等我，先能避害，然后才可趋利。因为利今天没有，明天还可以再图。而害却可能让我输掉老本，彻底出局。所以避害比趋利重要得多 下判断、做事业，要把握两条：趋利、避害。趋利和避害的权重，应该至少是相当的，五十对五十。但是，往往都成了七比三，甚至九比一。为什么，因为利往往在明处，在眼前，让人激动；而害在暗处，在远处，让人心生侥幸。我们经常看到人，去做一些利益极小，而隐患极大的事情。为什么呢？因为那利马上可以得到。而那害，那明明白白的害，他却不可救药地认为“不一定”。 奇兵 曹操注解说：“以五敌一，则三术为正，二术为奇。”如果有敌人并兵自守，不与我战，则有五倍于敌的兵力可攻。怎么攻呢，以三倍兵力为正兵出战，留两倍兵力在手作预备队等待出奇制胜 其他 中国有句古话叫“不知者不为罪”，大错！不知就是最大的罪！你不知，怎么担当这责任管这事呢？ 你如何能得到这张王牌呢？就是谁也没看到它的价值的时候，你先占了。那地，一直在那里，就像那牌，一直在那里，谁摸到是谁的，关键你得知道那张牌是王牌 不能因为你的队友是猪，你就跟着做猪]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库系统工程师（软考）]]></title>
    <url>%2F2018%2F09%2F08%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%88%E8%BD%AF%E8%80%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[大二下学期考了软考中级证书，期末查分过了。趁自己还记得，写点东西记录一下。 写在前面的几句废话这个是软考中级证书的一门，含金量还行吧，现在还没在什么招聘要求上看到它。听师兄说国企会在工资考评上算上它，有它能加几百块钱，不知道是不是真的。考它的主要原因是大二上学了数据库原理。大二下学期又比较闲，想以考带学，查漏补缺。简单介绍一下吧。数据库系统工程师资格（水平）考试，一年一次，大概在3 4月份网上报名，5月份考试。考试上午一场，下午一场。两场满分75,45分通过。上午题全是选择题，内容是理论知识，下午5道大题填空或者回答。没考试之前，我对于数据库的学习主要是大二一学期都按习题敲代码。对于增删查改，条件查询，视图、储存过程、触发器的代码比较熟悉。期末考虽然也有理论，但就是死记硬背，没有深入学透。考取这门证书，让我收获许多理论知识。诸如范式、关系代数。还有可怕的计算机专业知识的考查(ಥ_ಥ)比如校验码，补码，磁盘容量计算，流水线，计算机网络。。。敲代码以后可以好好搬砖。而学习这些理论知识比如范式、关系代数有什么用，我之前也有一些困惑。在知乎上有这样的问题，下面有一些不错的回答。https://www.zhihu.com/question/273489729最初完善数据库理论知识的目的达到了。不过，越学越觉得自己知识漏洞越多。。。 首先这门考试仅仅需要准备两本书，这两本都是考试官方指定用书。第一本是历年真题有超详细的解析，请认真刷完，第二本大砖头用于查漏补缺。tips：配合本文章末尾分享的视频食用更佳。 当时对我有帮助的博文。对于三级模式（ 外模式，内模式，模式）刘慰老师的回答让我有种恍然大悟的感觉，推荐阅读！。https://www.zhihu.com/question/38737183/answer/93294527 列了一些常见的概念 https://blog.csdn.net/BI_25_RED/article/details/52564110 我的软考之路https://www.cnblogs.com/clnchanpin/p/7358003.html 我个人做的一小部分笔记这部分随便看看就好- - 上午题常见的概念 s读锁（共享） 任何人只能读x写锁（排他） 只有那个人可以读或写 并发，就像一个人（cpu）喂2个孩子（程序），轮换着每人喂一口，表面上两个孩子都在吃饭。并行，就是2个人喂2个孩子，两个孩子也同时在吃饭。串行：喂完一个再喂第二个。 脏读 修改之后 被别人读到 但这个修改又被撤回作废 别人读到就是脏数据。简单来说就是读到的数据是人家不要的。幻读 一个事务两次查询，第二次比第一次多了或者少了几行几列数据不可重复读 和幻读差不多 不过幻读重点在insert更新丢失 回滚多了 undo 撤销 完成之后rollback 未全部完成redo日志 数据修改后的undo日志 数据修改前的 集成测试［在概要设计阶段］：接口，通信 黑确认测试［需求设计阶段］：最终用户系统测试恢复测试即容错测试 瀑布模型（理想）一个个阶段过，不回头原型（动态定义需求）螺旋模型 结合瀑布和演化并加入风险 小系统一圈一圈走阶段喷泉模型 （迭代）各阶段交叉‼️对风险进行识别和分析 标记耦合和控制耦合的区别：标记耦合传递不是简单的变量而是数据结构 人耳可听到的范围是20hz-20khz日常说话300-3400hz乐器20hz-20khz 共享性是指各结点数据共享。自制性是指每个节点对本地数据都能独立管理。可用性是指当某一场地故障时，系统可以使用其他场地上的副本，而不至于使整个系统瘫痪。分布性是指数据在不同场地上的储存。 笛卡尔积 的个数 等于两个个数相乘π投影 垂直 就一个表中只需要姓名和成绩，其他过滤∂选择 水平 中继器（转发器） 物理层网桥 数据链路层路由器 网络层网关（协议转换，交换机） 高层集线器 物理层 超健：唯一标识（知道学号姓名就可以知道她的年龄班级）候选健：超健基础上，不含多余属性（学号姓名知道一个就行了，但加一个课程名才知成绩）主键：候选健中随意挑一个候选健都是主属性 需求分析：数据流图和数据字典。逻辑设计：设计关系模式及相关视图。物理设计：设计数据的物理组织如索引。 将所有对象进行分类，然后确定各类的实体，找出属性，这一过程称为聚集。从实体中抽象出子类和父类这一过程称作概括。 事物的永久性是指事物一旦提交，其对数据库的影响是永久的，即使系统发生故障也不受影响，提交可以看作是系统对用户的承诺。 说说下午题中一些油腻腻的套路。 第一大题（数据流图）加工的输入数据流和输出数据流要平衡，保证加工的输出数据流都有对应的输入和输出数据流。绘制过程中可能出现的错误：数据黑洞：只进不出数据奇迹：只出不进数据灰洞：加工不出输出流 第二大题（sql代码）一个信息点一个信息的标记出来，别漏了。尤其喜欢让你补写GROUP BY。查询了多少个表，group by后面就要跟多少个表。当然函数比如avg（工资）不用。补写where。查询多少个表，where是表数减一条。 第三大题（设计实体）实体的关系不止于两个实体。喜欢考三个实体的关系。 第四大题（范式）第二范式：消除了非主属性对主属性的部分依赖。缺点是数据冗余，修改、删除、插入异常第三范式：消除了非主属性对主属性的传递依赖。缺点是删除、插入异常。BNF：消除了主属性对码的部分传递函数依赖。 第五大题，略。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《自卑与超越》]]></title>
    <url>%2F2018%2F09%2F08%2F%E3%80%8A%E8%87%AA%E5%8D%91%E4%B8%8E%E8%B6%85%E8%B6%8A%E3%80%8B%2F</url>
    <content type="text"><![CDATA[力荐这本书，作者是一名经验丰富心理医生，即便是读读这篇断章取义的摘录也可以感觉到这是一本能给人启迪的好书。 发现她询问过的女孩中有百分之四十二想要当男孩，这意味着她们对自己的性别不满。当尚有一半人口处于失意和灰心之中时，又怎么可能解决爱情和婚姻问题呢？当女性始终面临着轻视，并认为自己只是男性的性对象，或是认为男性的见异思迁和不忠是天性使然时，这些问题能够轻易解决吗？ 比如，有千千万万小说都是以新婚男女缔结良缘为结局，但那其实只是他们共同生活的开始。在这种情境下，小说常常将婚姻当作解决一切问题的灵丹妙药，就好像新婚夫妇从此一帆风顺，过上了幸福的生活。需要认识到的另一个重要事实是，爱情本身不能解决任何问题。爱情的形式各种各样，更有效的是靠努力、关心和合作解决婚姻的问题。 有人无法只爱一个人，他们必须得同时爱着两个人。只有这样才能让他们感到自由，他们可以从一个身边逃到另一个那里去，完全不用承担完整的爱情责任。两个都爱，等于谁都不爱。 我们知道，决定一个人的并不是他所处的环境，而是他对自身处境的解读。 爱情，以及它在婚姻中的圆满，是对异性伴侣最亲密的奉献，具体表现为生理上的吸引、相濡以沫的陪伴，以及生儿育女的共同愿望。 所有人都应该为自己的生活去挣钱，无视这一点的人会成为别人的负担。但如果孩子们只对挣钱感兴趣，便很容易脱离合作路线，一心只想着自己的利益。如果没有其他社会兴趣，只将“挣钱”当作唯一目标，为什么不能去抢、去坑蒙拐骗呢？就算不至于那么极端，就算拜金之下还残存有一丝社会兴趣，他们的行为对人类也不会有太多贡献 如果儿童从小就知道自己长大后想从事的职业，那他们的发展就简单多了。如果我们问他们长大想干什么，大部分儿童都会给出明确回答。然而，他们的答案通常并未经过认真思考。当他们说想当飞行员或汽车司机时，其实对自己所选择的职业并没有了解。我们的责任是挖掘出他们的回答下潜藏的动机，把握他们努力的方向，找出推动他们继续前进的因素，以及他们的目标和他们实现这个目标的方式。他们所选择的未来职业只是一种在他们看来体现了优越性的职业，但从这一选择上，我们可以发现其他的发展可能，去帮助他们实现目标。 天才的训练都开始于幼年。我觉得，关于天才的问题将有助于了解整个课题。只有那些对人类的共同利益做出过卓越贡献的个体才被称为天才。我还想不出有哪位没能对人类做出任何贡献的天才。 四五岁前的努力和训练对孩子成年后的主要活动范围有着决定性影响。做职业指导时，我总要询问每个人的幼年生活，以及他们早年对什么最感兴趣。他们对这一时期的记忆可以准确地揭示出他们最常进行的训练：他们会透露自己的理想，以及这些理想在自己心目中的地位。后文中，我会回过来讲最初记忆的重要性。 《罪与罚》中就是如此，主人公拉斯科利尼科夫在床上躺了两个月，考虑是否去杀人。他靠对自己质问“我是拿破仑，还是一只虱子”来鞭策自己。犯罪分子靠这样的幻想自我欺骗，自我激励。事实上，所有犯罪分子都知道，他们过着对社会无益的生活，也知道什么才是有用的生活。然而出于怯懦，他们拒绝有用的生活，而怯懦则是因为他们缺乏成为有用之材的能力。解决生命中的问题需要进行合作，他们对合作却一窍不通。之后，在想要逃脱自己的罪责时，我们会看见他们为自己辩护，想要博取宽容，“他有病”或是“他没工作”等等都被拿来当作借口。 碰儿童时必须多加小心。父母和孩子间温暖的拥抱和亲吻没有问题，只要没有不恰当地激起孩子的生理反应。成年人回忆童年时，经常有人跟我诉说在父母的书架上发现黄色读物或是看了色情电影之后的感受。最好不要让儿童接触到这些图书和影片。如果不在性欲上给孩子以刺激，可以避免很多麻烦。 有时候，教师会对懒惰的学生说：“如果努力一点，你就能成为班上最聪明的学生。”如果不费吹灰之力就能获得这样的评价，他们为什么还要冒险去努力呢？也许一旦他们不再懒惰，就保不住这种深藏不露的聪明孩子的名声了。所以应该根据实际成绩来裁判，而不是他们本应能达到的目标。懒孩子的另一个优势是，只要他们稍稍使一点点力气，就能得到表扬。所有人都希望他们至少是已经开始努力了，热切地鼓励他们进一步提高，但其实同样的努力在勤奋的孩子身上根本就不值一提。就这样，懒孩子生活在他人的期待里。他们是被宠坏的孩子，从婴儿时期就开始习惯于期待不劳而获 还有一些想要成为关注焦点的孩子，在周围环境不顺意时，就通过调皮捣蛋来获取关注。他们要么扰乱整个课堂，要么带领其他孩子逃学，要么不时惹是生非。责备和惩罚对他们毫无效果，只会让他们更加得意。他们宁愿被责罚也不愿被忽视，破坏行为所带来的不快惩罚对他们来说只是为了赢回关注所付出的合理代价。许多孩子只将惩罚视为个人挑战。他们把它当成竞争或比赛，看谁能坚持得更久。而赢家总是他们，因为主动权掌握在他们自己手中。所以有些与自己父母或老师作对的孩子，在接受惩罚时，不仅不会哭，还会笑。 智力发展中最大的要素是兴趣，我们之前说过，能够阻碍兴趣发展的是灰心和恐惧，而不是缺乏遗传。毫无疑问，大脑的结构多少得自遗传，但它只是心智的工具，而非根源，而且如果大脑的损伤还没严重到我们现今所掌握的知识无法克服的程度，就仍然可以接受补偿性训练。在每种出类拔萃的能力背后，我们所发现的都是持久的兴趣和训练，而不是特异的遗传性状。 “善”与“恶”，以及其他关于性格的表达，其意义都只存在于社会语境中。它们是在社会环境下，和其他人类共同培养训练出来的产物，它们蕴含着对一个人的行为是“有利他人”还是“损害他人”的判断。儿童出生前并没有能产生这一感知的社会环境 儿童和他们的父母也不应被告知智商分数。他们不了解测验的目的，也许会以为它代表着最终判决。教育最大的问题不在于儿童的极限，而在于他们的自我设限。如果孩子们知道他们的IQ分数低，也许就会丧失希望，认为自己与成功无缘。我们在教育中应该做的是尽力增强他们的自信和学习兴趣，破除生活中他们给自己的能力所加上的重重限制 现在有些学校已经采用视听结合的教学方法来上课，比如在传统课程中结合使用模型和图画。这一趋势值得鼓励并进一步发展。任何学科的最佳教学方式都是让它与现实生活紧密相关，让孩子能够看到教导的目的，并了解到所学内容的实用价值。有一个问题常常被提及，教孩子吸收知识和教会他们自我思考孰高孰低？在我看来，这两种方法不该割裂，而应该结合在一起。例如，结合造房子教数学就很生动有益，可以让他们算出需要多少木材，可以住多少人等等。 懒惰是野心与缺乏勇气并存的标志：野心如此之大，以至于人们看不到任何实现它的希望 在这类竞争中，女孩天生更有优势：在十六岁以前，无论身体还是心灵，她都比同龄男孩成长得快。结果可能就是她的哥哥放弃竞争，变得懒惰消极。这样的事情屡见不鲜。男孩有时会通过一些不那么光明磊落的手段来追求优势，比如吹牛和撒谎。在这种情形下，我们几乎可以立刻肯定女孩已经获得了胜利 这些性格特征并不只是见于人们清醒的时候。它们的痕迹体现于一切个性表达中，在睡梦中就更明显了。举例来说，长子女常常会做有关跌落的梦。他们本就处于顶端，但不确定自己是否能够一直保持这样的优势。而次子女则完全不同，他们常常勾勒出自己正在比赛的场面，或者是跟在火车后面奔跑，或者是骑着自行车比赛。有时候这些紧张匆忙的梦具有如此鲜明的特征，以至于我们可以轻易猜到做梦者是家中排行第二的孩子 有一种感觉一直吸引着教育者与心理学者的关注，那就是“害怕”。在个体心理学中，我们不再局限于寻找害怕产生的原因，而更注重探究它的目的。所有受宠爱的孩子都会害怕：透过害怕，他们能够得到关注于是他们将这种情绪建立在了自己的生活方式中。利用它，孩子可以成功地将母亲拖在身边。胆小的孩子往往都是娇生惯养的，而且希望能够继续被娇纵。 有一个娇惯的孩子常常会在黑暗中大哭。一天夜里，当母亲听到哭声赶过来时，她问孩子：“你为什么会害怕？”孩子回答：“因为太黑了。”但母亲现在已经认识到了他这种行为的目的。“那我进来之后，”她说，“就没那么黑了吗？”黑暗本身并不重要，孩子对黑暗的恐惧仅仅意味着他不想与母亲分开。他的所有情感、所有力气和所有精神都专注于要创造一种情境，在这种情境下，他的母亲就不得不来照看他，再次回到他身边他努力用哭泣、喊叫、无法入睡或其他能让自己成为一个麻烦小家伙的方式，将母亲吸引到自己身边。 家庭中无需权威，但却需要真正的合作。父亲与母亲必须通力合作，在有关孩子教育的问题上应当处处保持一致。无论父亲还是母亲，都不应表现出对某个孩子的偏爱，这一点极其重要。偏爱的危害怎么强调也不为过。孩子在童年时期出现的沮丧感，其根源几乎都在于感到有人比自己更受宠爱。 夫妻之间的性关系不容忽视。同样重要的是，当父母在向子女解释有关性的问题时，要小心不要一厢情愿地涉及太多，只要告诉孩子他们想要知道的，同时也是在他们当前的年龄阶段里能够理解的内容，就足够了。我认为当今有一种不恰当的倾向，那就是人们告诉孩子们的远远超过他们能够理解的。这可能诱发出一些孩子还没有准备好要应对的兴趣和感觉。性可能从此就变成了一件稀松平常、无足轻重的事情。这并不比过去人们在性问题上对孩子们欺骗或是讳莫如深来得高明。最好的方式，是找出孩子们真正好奇的是什么，实事求是地为他们做出解答，而不要将我们认为是常识的东西强加给他们。我们一定要保护他们的信任感，将我们正在与他们合作的感觉延续下去，至于我们真正应当关心的，是帮助孩子找到他们问题的解决之道。如果这样做了，我们就不会有太大的偏差 一位父亲的职责可以概括为几句话。他必须证明，自己是妻子的好伴侣，是孩子的好伙伴，也是社会的好成员。他必须妥善处理生活中的三大问题——工作、友谊和爱情，还必须在照顾和保护家庭时与妻子平等合作。他不应忘记，女性在家庭生活中的地位是不容贬抑的。贬低母亲的地位并非他应该做的，相反，他应当与妻子相互配合。需要特别强调的一个重点在于，即便父亲是家庭的主要经济支柱，这也是夫妻共同的收获。他绝不可摆出一副施予者的模样，把家庭中所有其他人都变成接受者。对于和谐的婚姻来说，真相是，他去赚钱只不过是家庭劳动分工的结果。许多父亲利用他们的经济地位来作为统治家庭的理由。家庭中不应存在统治，任何可能导致不平等感的事情都应当被避免。 由于婚姻是平等的合作关系，所以没有哪一方应该凌驾于另一方之上。这一点应当值得更深入的探讨，而不是满足于我们已经习惯的状态。在家庭生活的所有行为中，最不需要的就是权威的存在，如果家庭中某一位成员特别重要，或是被认为其价值远远大于其他家庭成员，那就太不幸了。如果父亲脾气暴躁，试图掌控家庭中的其他成员，那么他的儿子对于男人的概念就会有所偏差。而他的女儿则会更加痛苦。在未来的生活中，她们都会将男人看成暴君。对她们来说，婚姻就意味着某种屈从和奴役。有时，当成年以后，她们还可能发展出对同性的兴趣，以此来寻求自我保护，对抗男性。 众所周知，继母不好当，失去了亲生母亲的孩子常常会与她们对抗。但问题并非不能解决的，我也曾经看到过许多非常成功的继母。只是太多时候继母都没有真正明白情况究竟是怎样的。一种可能的情况是，孩子在失去母亲后转而寻求父亲的关怀，并且得到了他的宠溺。而当父亲再婚时，他觉得父亲的宠爱被瓜分了，于是攻击继母。而继母如果觉得自己必须反击，那孩子就真的委屈了。她挑战了他们，于是他们奋起反抗。任何与孩子对抗的战斗终究都会是一场失败的战斗：他们永远不会被打败，也不会因为被战胜而与对手合作。在这些斗争中，最弱小的往往都是最后的胜利者。他们会拒绝提供被要求的东西，这样的方式注定难有收获。如果我们意识到合作与爱是永远无法靠力量强行获取的，想必这个世界上的紧张压力和无用功就会大大减少了 现在就让我们来看看她的梦吧。“好几个人和我一起坐在车里。”正如我们推测的，她擅长合作，喜欢和别人待在一起。“我们一直开到一片树林前面才停下来。每个人都下车跑进了树林里。他们中大部分人都比我个子大。”她再一次留意到了个头的差异。“但我努力及时赶到，和大家一起上了一部电梯。电梯向下开进了一个大约十英尺深的矿井里。我们都觉得，要是走出去一定会瓦斯中毒的。”现在她描绘出了一个危险情况。大多数人都会害怕某些确定的危险，要知道人类并非勇敢的生物。可是她的梦还有下文。“后来，我们走了出去，全都安然无恙。”在这里，你可以看到乐观的精神。如果一个人是乐于合作的，他们通常都会勇敢、乐观。“我们在那里待了一分钟，然后回到地面，赶快跑回了车里。”我深信这名女孩一直都是乐于合作的，但始终有个念头困扰着她——她总觉得自己如果能再高大一些就好了。在这里我们应该能看出一些紧张感，就好像能看到她踮起脚的模样一般。好在她喜欢与人交往，对分享成就很感兴趣，这能消解掉许多紧张感 她是个漂亮的姑娘，却总觉得人们都只不过是因为她好看的容貌才喜欢她，因此很害怕变丑或受伤。有魅力的人在我们的社会中更容易被人们记住，也更容易支配他人，这位姑娘就很明白这一点。可她还是想要成为一名男子，以男性的方式来掌控一切。所以心底里其实不太看重自己的美丽。 她最早的记忆是关于曾被一个男人吓到的故事，而且她也承认自己至今仍旧害怕会成为窃贼或袭击者的攻击目标。这看起来有些奇怪，一个有男性化倾向的女孩竟会害怕窃贼和袭击者。但其实并不奇怪，正是她的软弱决定了她的目标。她希望能在自己熟知并掌控的环境下生活，排除一切其他情况。窃贼和袭击者恰恰是不可控的，因此她更乐意将他们统统消灭。她想要轻轻松松地变成一个男性化的人，这样，就算不幸失败了，也总算是有个过得去的保护伞。我将这种对于女性角色的深刻不满称为“男性钦羡”（masculine protest），它的出现总是伴随着一种紧张感：“我是一个正在为身为女性的种种不利而努力抗争的人。 以下的考察能够直接帮助我们厘清梦的意义。我们在夜里做梦，但在清晨来临时却常常将梦境忘得一干二净。看似水过无痕，毫无踪迹可循。但真是这样吗？真的什么都没有留下吗？答案是，有的。梦所带给我们的感觉还保留着。没有任何画面，没有任何对于梦的理解，只有感觉久久萦绕。梦的目的必定就在于它们所激发出的感觉之中。而梦就是唤起感觉的工具与方式。之所以有梦，就是为了留下这些感觉 我们已经知道，人们认为梦能够为他们遇到的难题提供解决方案。由此不妨推论，人们做梦的目的就是为了寻找对于未来的指引和当前难题的解决方法。这与梦能够提供预示的观点相去甚远。我们还必须考虑到，做梦的人想要得到的是什么样的解决方案，又是从哪里找出它们的。很显然，比起对实际形势做出全盘考察并且审慎思考后找到的解决方法，出现在梦里的那些看起来会更糟糕一些。毋庸赘述，事实上，做梦的人只是希望能够在睡梦中轻松解决掉他们的麻烦。 “看来你的父亲是大错特错了，”我说，“他无时无刻不在想着将他的权威加诸你身上，这是非常不明智的。也许他有一些问题，需要看看医生。但你能怎么办呢？你不能期望去改变他。比方说，下雨了，你能做什么呢？你可以撑把伞，或是搭乘出租车，无论如何，想要打败甚至制服雨都是不可能的。而现在，你就是在和雨战斗。你认为这能够展示你的力量，能占据上风。但实际上，你比其他任何人所受到的伤害都多。 小时候的他是个不在乎整洁的孩子，羞怯、怕黑、害怕孤独。当我们听到孩子不爱干净时，就知道，一定是有人跟在他们身后随时收拾。当我们听到孩子害怕黑暗和孤单时，就能推断，一定有人总是在关注着他们，会去安慰他们 “过了一会儿，我们觉得想要再多尝一点，于是就自己动手了。”这是个勇敢的姑娘。她希望独立。“就在这时我的腿软了，苹果酒被打翻在地，酒窖里湿了一大片。”在这里，我们看到了一个禁酒主义者诞生的苗头。 “我不知道这件事跟我不喜欢苹果酒和其他酒精饮料有没有关系。”再一次，一个小小的意外事件成为了一个完整生活态度的成因。如果我们就事论事地来看，这件事并没有重要到足以造成如此深远影响的程度。可是这位女孩却把它当作了不喜欢酒精饮料的充足理由。我们或许能够发现这位女孩是一个善于吸取经验教训的人。也许她非常独立，犯错时总会自我纠正。这种品质可能是她整个生活的一大特点。从整段描述来看，她在说的似乎是：“我会犯错，但只要我发现了错误，就能及时改正。”如果是这样，她就能具备很好的性格，积极主动，勇于进取，总是渴望自我完善并改善处境，自然也就能拥有好的、有益的生活 当一个孩子被“炫耀”，那么他的兴趣很可能就在于赢得社会大众的喜爱，而非对其做出贡献 如果医生被问到他的早期记忆，那么多半都会有一些关于死亡的片段。“躺在棺材里，那么安静，那么苍白”——这是有关某个画面的记忆。这个女孩可能是视觉型的，喜欢观察世界 而最具启发性的，一是儿童展开他们故事的方式，二是他们能够想起的最早的事件。第一个记忆体现了个人生命观的基本准则，这是第一次令他感到满意的对于个人态度的表达。这令我们得以一窥他们所选择的个人发展的起点究竟是什么。若要探究一个人的个性，我绝不会不询问他最早的记忆。 在所有的心灵表达中，最能揭示真相的是个体的记忆。记忆是人们随身携带的提示器，记录着有关他们自己的局限和各种事件的意义。世上没有“偶然的记忆”。个体接受到的印象数不胜数，人们只会从中挑选出自认为与个人问题有关的来纳入记忆，不管它们是多么的模糊不清。这些记忆代表着他们的人生故事，一个他们不断对自己重复以从中摄取温暖或舒适感的故事。这个故事可以帮助人们将注意力集中在他们的目标上，或是用过往经验中的意义来武装他们，让他们可以用一种更为可靠的、经得起考验的方式来迎接未来。从日常的行为中，我们可以清楚地看到，记忆的作用在于稳定情绪。如果一个人遭遇了挫折，并且为之沮丧，那么他就会回想起从前曾经遭遇过的挫折。而当他感到振奋、高兴，充满勇气时，他就会选择完全不同的记忆，他想起的是那些高兴的事情，这些记忆让他更为乐观。同样的道理，如果遇到了一个难题，他就会唤出那些能够帮助自己调试好恰当态度的记忆，以便应对当下的情形 我们能够看出，伴随着对于缺憾的切实补偿，有人排除了某些可能性，有人却针对自我的局限加以训练。哲学家们为什么必须一次又一次地避世而居才能够思考和写作？由此就可以理解了。假使一个人的优越目标里匹配了高度的社会兴趣，那么虽说任何目标都难免有错失，可这个目标的错误却也不会太大。 我们人类的劳动分工为各种不同的目标提供了生存空间。或许，正如我们所见的，每一种目标都多多少少有一定的偏差，我们总能从中找出些可以批评的地方。可是人们的合作所需要的正是取长补短。对某一个孩子来说，优越感可能在于他所擅长的数学知识，对另一个而言则在于艺术，而第三个孩子又以健壮的体格见长。消化不良的孩子可能会认为自己的问题主要出在营养方面。如果相信研究食物能够改善他们的处境，那么他们的兴趣就有可能转向这一方面，结果就是，他们或许会成为一名职 当陷入爱情时许多人都会感到软弱，在一定程度上，他们是对的。如果我们在恋爱，就必定变得温柔，我们对另一个人的兴趣也会让自己更容易受到伤害 时至今日，我们还是常常在针对表征来处理问题。无论在医学上还是教育上，个体心理学都完全反对这种做法。如果孩子的数学一塌糊涂，或是在学校的表现很糟糕，那么我们若是仅仅针对这些方面来试图有所提升，只能是徒劳无功。或许他们是想让老师难受，甚至希望闹到被开除好彻底逃离学校。如果我们只用单一的方法来阻止他们，那他们总能找到另一条对策来达到他们的目的。 举例来说，我们时常发现，成为医生的人往往在他们童年很早的时候就开始面对死亡的现实。死亡给他们带来的最大印象，是威胁人类不安全外在的一个侧面。或许是双亲或兄弟姐妹中有人死去了，于是在他们后来的学习发展中，便致力于为自己或他人找到对抗死亡并增加安全感的方法。也有人将成为教师作为他们明确的目标，但我们很清楚究竟有多少种不同的教师。如果一名教师的社会情感程度较低，那他的优越目标就有可能是通过当老师成为小范围内的大人物。或许，只有在比自己更弱小、更没经验的人面前他才会觉得安全。而拥有高度社会情感的教师则会以平等的态度对待学生，他们是真心希望能够为人类福祉做出贡献的。在这里，我们只需要提出，教师与教师之间的能力和兴趣差别有多么大，而从他们的言行中又能如何清楚地看到其各自的个人目标。当一个目标被清晰地勾勒出来，个体的潜力就会被修剪压缩到适合这个目标；至于整体的目标——我们可以将它称为原型——却会在任何情况下都努力突破这些限制，找到一个途径来表现其个人设定的生命意义和争取优越感的终极理想 成年人的神经官能症也是这样。设想一个例子，就说饱受偏头痛之苦的人们吧。头痛对他们来说就是很有用的工具，只要需要，它们就可以在任何特别的时刻发作。借助于头痛，他们可以不必面对生活中的麻烦。当他们不得不和陌生人打交道或是做决定时，头痛招之即来。与此同时，头痛还可以帮助他们操控他们的同事、搭档或家人。我们怎么能指望他们会放弃这样一种有力的武器呢？他们将疼痛加诸己身，但从他们的角度来说，却是再明智不过的投资了——它会带来所有他们能够期望的回报。当然，我们可以给患者一个惊人的解释来吓走他的头痛，就像用电击或一场假手术来治好士兵的战争疲劳症（shell-shocked）一样。或许药物治疗也能令某些症状有所缓解，让病人难以继续使用这些特别选择出来的症状。但是，只要他们的目标没有改变，哪怕治好了一种症状，他们也会找到另外一种来取而代之。“治好”了头痛，接着就可能出现失眠，或是其他一些新的症状。只要目标依旧，他们就一定要继续为之努力 举例来说，我们时常发现，成为医生的人往往在他们童年很早的时候就开始面对死亡的现实。死亡给他们带来的最大印象，是威胁人类不安全外在的一个侧面。或许是双亲或兄弟姐妹中有人死去了，于是在他们后来的学习发展中，便致力于为自己或他人找到对抗死亡并增加安全感的方法。也有人将成为教师作为他们明确的目标，但我们很清楚究竟有多少种不同的教师。如果一名教师的社会情感程度较低，那他的优越目标就有可能是通过当老师成为小范围内的大人物。或许，只有在比自己更弱小、更没经验的人面前他才会觉得安全。而拥有高度社会情感的教师则会以平等的态度对待学生，他们是真心希望能够为人类福祉做出贡献的。在这里，我们只需要提出，教师与教师之间的能力和兴趣差别有多么大，而从他们的言行中又能如何清楚地看到其各自的个人目标。当一个目标被清晰地勾勒出来，个体的潜力就会被修剪压缩到适合这个目标；至于整体的目标——我们可以将它称为原型——却会在任何情况下都努力突破这些限制，找到一个途径来表现其个人设定的生命意义和争取优越感的终极理想 我的一名病人在家中排行老二，他深受无法摆脱的罪恶感的困扰。他的父亲和哥哥都极其重视诚实这种品质。然而，在他七岁那年，他告诉学校老师，自己独立完成了一份家庭作业，可事实上，这份作业是哥哥帮他做的。这个男孩将他的罪恶感隐藏了三年。最后，他去见老师，坦承了这个糟糕的谎言。可老师只是付之一笑。接下来，他又哭泣着找到父亲，作了第二次坦白。这次他更成功一些，父亲为儿子的诚实而感到骄傲，夸奖并安慰了他。但尽管父亲原谅了他，男孩还是非常沮丧。至此，我们很难回避以下的结论：这位男孩为了这样微不足道的过失而如此严厉地自责，其实是想要证明自己高度的诚实与严谨。家庭中高尚的道德氛围使他期望在诚实方面有卓越的表现。面对哥哥在学业和社会上的成功，他感到自卑，因此努力尝试另辟蹊径来争取优越感 人们的兴趣和注意力指向何方，这是一个问题。如果朝着自我之外的目标而努力，那么自然而然地，他们就会很好地训练自己，做好准备，以求达成目标。任何困难在他们眼中都不过是成功路上需要跨越的障碍而已。反过来，如果他们的兴趣点只在于强调自身的不足，或是虽然对抗这种不足，但只是为了使自己从中脱身，他们就很难取得真正的进步。一只笨拙的右手不会因为人心里想着要变得灵巧，盼望着少些笨拙，甚至避开那些会显示出其笨拙的场面，就变成了灵巧的右手。只有通过实打实的练习，笨拙的手才有可能灵巧起来，并且对于“将来能够做好”的渴望，要远远超过当下的笨拙所带来的挫败感。如果孩子们要调动他们的能量来克服困难，那么一定得有一个外在于自身的行动目标，这个目标建立在对于现实、他人乃至合作的兴趣之上。 一项针对梦境和联想的调查可能被证实是有用的：个性人格无论在梦境中还是现实生活中都不会改变，但在梦境中时来自社会的压力相对较小，也无需那么多的戒备与隐藏，个性得以更多的释放。然而要破解人们赋予自己以及个人生活的意义，最有力的帮手便是他们的记忆库了。每一份记忆，哪怕是被他们自己视为微不足道的琐事，都很重要。只要记得，就说明它们值得记忆，而之所以值得记忆，是因为这些都与他所设想的生活相关。它在对他们附耳低语，“这是你应该期待的”，或“这是你一定要避免的”，甚至断言“这就是人生”。在此我们必须重申，经验本身并非如它们在记忆中所占的地位那么重要，重要的只是它们的用途——被用来印证生命的意义。每一份记忆都经过了我们的粉饰 五岁前，儿童已经形成了一套完整而牢固的行为模式，能够开始用他们自己的方式来应对问题和任务，我们将这称为他们的“生活方式”。他们已经形成了个人最为根深蒂固，也最恒定的概念，知道能对世界和自身期待些什么。从此以后，世界在他的眼里就被放进了一个固定的统觉[2]框架中。一切经验都得经过解读后才会被接受，而这解读又往往离不开儿童时期形成的对生命意义的原初理解。 以爱情与婚姻为例吧。如果我们关心自己的爱人，如果我们能够竭尽所能地令爱人的生活舒适富足，那么自然就会呈现出最好的自己。反之，假如我们认为应该在一个纯粹的环境下发展自我人格，拒绝一切有利于他人的动机，那么只会成为一个嚣张跋扈、令人生厌的家伙。 所有真实的“生命的意义”都有一个共同标志，那就是它们都具有普遍意义——能够为众人所分享，为他人所接受。对于生命中种种问题来说，一套切实可行的解决方案同时也是为他人树立的样板范例，因为它提供了一个解决普遍问题的成功之道。即便是最伟大的天才也无法超脱出“卓有建树”这样的评价——只有当一个人的生命被其他人认为是举足轻重的时候，他才有可能被称为“天才”]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博文]]></title>
    <url>%2F2018%2F09%2F06%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E6%96%87%2F</url>
    <content type="text"><![CDATA[我的征途，是星辰大海]]></content>
  </entry>
</search>
