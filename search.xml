<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>读源码后把自实现的线程池改成了这样</title>
      <link href="/2019/06/01/%E8%87%AA%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2019/06/01/%E8%87%AA%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本文分为三个部分：<br>一、如何实现一个简单的线程池？<br>二、jdk线程池源码分析<br>三、改进自实现的线程池</p><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>昨天面试，说起线程池，我无意中提起自己写过一个简易线程池。面试官问我了解工厂模式吗。晚上回来一查看，果然java线程池底层是用了工厂模式。<br>这挺好理解的，线程池工具类Executors的方法创建，比如FixedThreadPool固定线程池。点进方法去看是返回一个定义好初始化的参数线程池实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int</span><br><span class="line">nThreads) &#123;    return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,                                  new</span><br><span class="line">LinkedBlockingQueue&lt;Runnable&gt;());&#125;</span><br></pre></td></tr></table></figure></p><p> 单例模式的好处是：</p><ul><li>用户只要知道名字就行了，比如我想创建一个固定长度的线程池，只需要调用newFixedThreadPool（）方法，而不需要在了解ThreadPoolExecutor构造函数之后自己new一个配置一堆参数。省心省力。</li><li>而且如果不是java底层源码这种不会被修改的代码，构造函数的参数变了，所有用来new一个该地方的代码都得改。</li></ul><h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><p>话不多说，大家看这篇博客方法表格就全懂了。——&gt;点进去第一个表格<a href="https://blog.csdn.net/qq_42135428/article/details/80285737" target="_blank" rel="noopener">Java高并发之BlockingQueue</a><br>上一篇我是用syn锁住任务队列，工作线程wait和notify去实习生产者消费者，这篇用LinkedBlockingQueue的put和take方法来实现。如果put或者take试图的操作无法立即执行，这两个方法调用将会发生阻塞，直到能够执行。</p><h2 id="创建线程方式改进"><a href="#创建线程方式改进" class="headerlink" title="创建线程方式改进"></a>创建线程方式改进</h2><p>还有上文文末提到过，线程池中的线程的创建不是在构造函数中，而是在有工作线程过来的时候才创建。<br>这次一并用这些知识点把之前的简易线程池升级重写一遍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line">import java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line">public class ThreadPool &#123;</span><br><span class="line">    //工作线程数</span><br><span class="line">    private int workerCount;</span><br><span class="line">    // 线程池大小</span><br><span class="line">    private int corePoolSize;</span><br><span class="line">    // 任务容器</span><br><span class="line">    private BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line">    //工作线程容器</span><br><span class="line">    private Set&lt;Worker&gt; workers;</span><br><span class="line">    // 任务容器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static ThreadPool threadPool;</span><br><span class="line"></span><br><span class="line">    public static ThreadPool newThreadPool() &#123;</span><br><span class="line">        threadPool = new ThreadPool(3);</span><br><span class="line">        return threadPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ThreadPool(int corePoolSize) &#123;</span><br><span class="line">        this.corePoolSize = corePoolSize;</span><br><span class="line">        //LinkedBlockingQueue的默认容量是Integer.MAX_VALUE，一直加任务线程可能会造成OOM内存溢出</span><br><span class="line">        workQueue = new LinkedBlockingQueue&lt;&gt;(1024);//这里指定大小</span><br><span class="line">        workers = new HashSet&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void execute(Runnable r) &#123;</span><br><span class="line">        if (workerCount &lt; corePoolSize) &#123;</span><br><span class="line">            addWorker(r);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                workQueue.put(r);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void addWorker(Runnable r) &#123;</span><br><span class="line">        workerCount++;</span><br><span class="line">        Worker worker = new Worker(r);</span><br><span class="line">        Thread t = worker.thread;</span><br><span class="line">        workers.add(worker);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Worker implements Runnable &#123;</span><br><span class="line">        Runnable task;</span><br><span class="line">        Thread thread;</span><br><span class="line"></span><br><span class="line">        public Worker(Runnable task) &#123;</span><br><span class="line">            this.task = task;</span><br><span class="line">            this.thread = new Thread(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                Runnable task = this.task;</span><br><span class="line">                // 执行当前的任务，所以把这个任务置空，以免造成死循环</span><br><span class="line">                this.task = null;</span><br><span class="line">                if (task != null || (task = getTask()) != null) &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Runnable getTask() &#123;</span><br><span class="line">        Runnable r = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            r = workQueue.take();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class TestThreadPool &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        ThreadPool threadPool=ThreadPool.newThreadPool();</span><br><span class="line">        //生成10个任务放入线程池</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            Runnable task=  new Runnable()&#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    System.out.println(&quot;做任务中。。。&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            threadPool.execute(task);</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.runoob.com/design-pattern/factory-pattern.html" target="_blank" rel="noopener">模式方面菜鸟教程写的不错</a></p><p><a href="https://blog.csdn.net/qq_42135428/article/details/80285737" target="_blank" rel="noopener">Java高并发之BlockingQueue</a></p><p><a href="https://blog.csdn.net/GitHub_boy/article/details/51046574" target="_blank" rel="noopener">https://blog.csdn.net/GitHub_boy/article/details/51046574</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019春</title>
      <link href="/2019/06/01/2019%E6%98%A5/"/>
      <url>/2019/06/01/2019%E6%98%A5/</url>
      
        <content type="html"><![CDATA[<p>我想，博客不止要有技术，更新一些生活，更能体现个人风格。所以以后每一个季度写一篇关于生活的博文。文笔不行，写出来的日记可能就是杂乱无章毫无逻辑的流水账。也不知道能坚持多久。</p><p>这个学期是我在学校的最后一段时间，还跟别人说“晚上在床上想到要毕业了，都能自己笑出声”。但其实这段时间并非很开心。<br>3月去面了一些大厂想长长见识。面试从城区坐大巴回来，看着窗外的这个城市，想着今天这次暴露自己哪方面哪方面不行，想着接下来应该往哪方面做，想着还是自己做的不够多。<br>4月有一个蓝桥杯比赛，当时报名的目的就是让对算法一无所知的我，有一个驱动力去啃算法。刷题了两个星期，拿了省三。都不太好意思往简历上写。<br>5月拿到了一些公司的offer。</p><p>拍毕业照的前一天晚上发现kindle不见了，这已经是我第三部kindle啦，短期内也没钱再买一部了。</p><p>牛客群认识一群小哥哥们，未来一起向秋招进攻吧，我是全群最菜没跑了。</p><p>自己的职业专业方向变得清楚，服务端+互联网。github是最近一段时间最经常打开的网站。</p><p>找租房找到头大，城中村不安全，稍微好一点的单间都1.6+，小区房更合租又担心这担心那的。找房烦过找工作。</p><p>最近唯一有关注的综艺是创造营，曾追过孟美岐那一季，节目组设计有少女心。这一季小哥哥们有点参军入伍的感觉，还拉练上下铺行军包hhh总之相比上一季富养小姐姐们是挺苦的，这次节目组挺阳光的，原创歌里面字眼都是“勇气”“拼搏”“出众”上一季觉得美岐宣仪不错，这一季周震南海星，宿友说我都是喜欢第一名hhhh</p><p>最后来一个心得+鸡汤套餐吧，送给如果最近也生活充满压力的你，共勉。<br>心得：当心态崩了该怎么调节？<br>对自己说，<strong>你的情绪不等同你自己。冷静的感知到自己现在是有这样的情绪的，但不要允许自己沉浸在这些情绪里面。</strong>在知乎看看怎么应对负面情绪，或者写写未来的计划，或者想一想这些情绪产生的原因。当做一些可能有用的小行动的时候感觉就会好一些。不要就干坐在那里发呆越想越难受。</p><p>鸡汤：在牛客看到一句话，大家毕业心态变化都是：我很强——&gt;我好菜——&gt;绝望了——&gt;坚持——&gt;offer求比较。吃力有时候说明你在走上坡路。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>手写http服务器（一）</title>
      <link href="/2019/05/29/%E6%89%8B%E5%86%99http%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2019/05/29/%E6%89%8B%E5%86%99http%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这里默认读者是连http服务器是啥一点概念都没有（但是得有网络编程基础），会从最基本的概念讲起，一步步写一个服务器，大神就不要点进来看我献丑了hhh</p></blockquote><h1 id="版本全览"><a href="#版本全览" class="headerlink" title="版本全览"></a>版本全览</h1><p>版本一：基于bio百行代码实现http服务器<br>版本二：基于nio<br>版本三：serlevt容器、cookie、封装、日志<br>版本四：长连接、参考了tomcat设计</p><h1 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h1><p><em>早在学jsp的时候，就很好奇tomcat是什么，为什么可以运行jsp、servlet？当时试图看业界盛誉的《how to tomcat work》，没看懂（但这确实是本神书）；问师兄，师兄也不太清楚。网上的博客就更不用说了。这个困惑就先被我放到一边去了。<br>寒假的时候用socket、多线程写了一个聊天室。突然明白，其实tomcat就像一个聊天室的服务器啊，浏览器相当于客户端，HTTP请求响应相当于聊天消息，浏览器给服务器发消息，服务器做处理。http报文只是遵守一定格式的字符串。<br>只不过聊天室的服务器是把收到的信息转发给其他客户端。而HTTP的服务的返回一个符合HTTP协议的消息。<br>最初的版本v1，只能把收到的HTTP报文打印到控制台，返回浏览器响应显示一句话。<br>后来发现github上比我大一两届的前辈也写过这个东西，但是他们有好多功能比如基于nio、servlet等等，像模像样。受到启发，这项目认真起来大有搞头。就有了把这个当成自己的一个项目去完善的心态。看了一些书、博客、视频。最近还发现群里的小伙伴也有在写这个的，此处点名糖糖。</em><br>写这个服务器的好处：</p><ul><li>写轮子所需几乎覆盖java所有知识点，因为即使是一个xml解析也要自己写，不像写后台一样有很多框架、工具可以用。</li><li>成就感强。tomcat算比较适合自己造轮子的入门中间件。曾经也有写一个Spring的想法，但看了源码之后就放弃了。Spring源码优秀，适合参读，但不太适合自己撸一个。</li><li>对后台开发的眼界会</li></ul><h1 id="V1"><a href="#V1" class="headerlink" title="V1"></a>V1</h1><h2 id="关键字：bio、百行代码内"><a href="#关键字：bio、百行代码内" class="headerlink" title="关键字：bio、百行代码内"></a>关键字：bio、百行代码内</h2><p><strong><em><a href="https://github.com/wangxuanni/MyTomcat/tree/master/src/v1/BioServer.java" target="_blank" rel="noopener">代码链接</a></em></strong></p><h2 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h2><ul><li>BIO</li><li>Socket</li><li>缓存线程池</li><li>lambda表达式</li><li>HTTP请求响应报文</li></ul><h2 id="5个步骤的关键代码"><a href="#5个步骤的关键代码" class="headerlink" title="5个步骤的关键代码"></a>5个步骤的关键代码</h2><p>一、开启服务器绑定端口<br><code>ServerSocket serverSocket = new ServerSocket(8080);</code><br>二、一直循环等待<br><code>while（true）{</code><br>三、收到请求的套接字<br><code>Socket socket = serverSocket.accept();</code><br>四、套接字可以获得一个字节输入流，把这个输入流转成字符串，打印在控制台。<br><code>InputStream inputStream = socket.getInputStream();</code><br>五、创建响应报文（其实就是按照HTTP报文的格式构建的一个字符串）并返回响应<br><code>BufferedWriter bw =new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));</code></p><h2 id="注意一些小坑"><a href="#注意一些小坑" class="headerlink" title="注意一些小坑"></a>注意一些小坑</h2><p>缓存字符流写入后记得要刷新！！！bw.flush();<br>选择缓存线程池是因为它更适合短连接。<br>构建响应报文用StringBuilder比String更好<br>响应报文正文要构建好并且要记录长度，因为响应头有一个Content-length:正文长度属性要填<br>记得在finally块把socket.close()关闭</p><h1 id="V2"><a href="#V2" class="headerlink" title="V2"></a>V2</h1><h2 id="关键字：NIO"><a href="#关键字：NIO" class="headerlink" title="关键字：NIO"></a>关键字：NIO</h2><p>这个版本主要从bio升级为nio。<br><strong><em><a href="https://github.com/wangxuanni/MyTomcat/tree/master/src/v2" target="_blank" rel="noopener">代码链接</a></em></strong><br>v2<br>最重要是弄懂nio是时候掏出我之前的bio、nio笔记了。</p><h3 id="bio"><a href="#bio" class="headerlink" title="bio"></a>bio</h3><p>先讲一下bio抛砖引玉，主要是为了和nio做对比。</p><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p>阻塞并同步。特点是IO两个阶段被阻塞。基于流模型。<br>客户端一个请求服务端就启动一个线程，线序发生请求给内核，由内核去通信，在内核准备好数据之前，线程是被挂起的，知道数据从内核复制到用户空间。调用是可靠的线性顺序<br>缺点：每次请求创建一个线程在销毁开销比较大，操作系统对线程的总数有限制，太多服务器可能瘫痪。可以用线程池改进。<br>创建bio服务器只需要一步。</p><h4 id="2-配置服务器"><a href="#2-配置服务器" class="headerlink" title="2.配置服务器"></a>2.配置服务器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一、ServerSocket serverSocket = new ServerSocket(8080);</span><br></pre></td></tr></table></figure><h4 id="3-处理请求返回响应"><a href="#3-处理请求返回响应" class="headerlink" title="3.处理请求返回响应"></a>3.处理请求返回响应</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">二、一直循环等待</span><br><span class="line">`while（true）&#123;</span><br><span class="line">三、收到请求的套接字</span><br><span class="line">`Socket socket = serverSocket.accept();`</span><br><span class="line">四、用套接字得到输入输出流，处理请求响应</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nio"><a href="#nio" class="headerlink" title="nio"></a>nio</h3><h4 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1.概念"></a>1.概念</h4><p>非阻塞并同步。可构建多路复用、同步非阻塞的io操作。特点是程序去不断询问内核是否准备好，基于buffers。<br>客户端请求会注册到多路复用上，单线程轮询到有io请求时，才启动一个线程进行处理，仅仅selector是阻塞的。<br>核心：Channels（类似流，全双工，可以读写。socketChannel、serverSocketChannel）<br>buffers8种基本类型都有，数据从channel读到buffer中，也可以从buffer写到channel。本质是一块方便读写数据的内存<br>selector多路复用器，以监听多个Channel通道感兴趣的事情。允许单线程处理多个channel。 </p><ul><li>OP_ACCEPT: 接收就绪</li><li>OP_READ: 读取就绪</li><li>OP_WRITE: 写入就绪</li><li>OP_CONNECT: 连接就绪</li></ul><p>一个server socket channel准备好接收新进入的连接称为“接收就绪”。某个channel成功连接到另一个服务器称为“连接就绪”。一个有数据可读的通道可以说是“读就绪”。等待写数据的通道可以说是“写就绪”。<br>所以只有OP_ACCEPT: 接收就绪是serviceSocketChannel使用的，其他三个都是socketChannel使用。</p><h4 id="2-配置服务器-1"><a href="#2-配置服务器-1" class="headerlink" title="2.配置服务器"></a>2.配置服务器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">     /**</span><br><span class="line">         * 1. 创建Selector</span><br><span class="line">         */</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        /**</span><br><span class="line">         * 2. 通过ServerSocketChannel创建channel通道</span><br><span class="line">         */</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        /**</span><br><span class="line">         * 3. 为channel通道绑定监听端口</span><br><span class="line">         */</span><br><span class="line">        serverSocketChannel.bind(new InetSocketAddress(8000));</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 4. **设置channel为非阻塞模式**</span><br><span class="line">         */</span><br><span class="line">        serverSocketChannel.configureBlocking(false);</span><br><span class="line">        /**</span><br><span class="line">         * 5. 将channel注册到selector上，监听连接事件</span><br><span class="line">         */</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        System.out.println(&quot;服务器启动成功！&quot;);</span><br></pre></td></tr></table></figure><p>总结一下上面代码，创建多路复用器，创建ServerSocketChannel，简称ssc，ssc绑定端口并设置为非阻塞，将ssc注册到多路复用器上，监听连接事件。到这里服务器已经配置好了。</p><h4 id="3-处理请求返回响应-1"><a href="#3-处理请求返回响应-1" class="headerlink" title="3.处理请求返回响应"></a>3.处理请求返回响应</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line">    while (true) &#123;</span><br><span class="line">    int readyChannels = selector.select();</span><br><span class="line">    if (readyChannels == 0) &#123;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">    Iterator iterator = selectionKeys.iterator();</span><br><span class="line"></span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">        SelectionKey selectionKey = (SelectionKey) iterator.next();</span><br><span class="line"></span><br><span class="line">        if (selectionKey.isAcceptable()) &#123;</span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            socketChannel.configureBlocking(false);</span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">            Response response = new Response(socketChannel);</span><br><span class="line"></span><br><span class="line">            response.print(&quot;&lt;html&gt;&quot;);</span><br><span class="line">            response.print(&quot;&lt;head&gt;&quot;);</span><br><span class="line">            response.print(&quot;&lt;title&gt;&quot;);</span><br><span class="line">            response.print(&quot;服务器响应成功&quot;);</span><br><span class="line">            response.print(&quot;&lt;/title&gt;&quot;);</span><br><span class="line">            response.print(&quot;&lt;/head&gt;&quot;);</span><br><span class="line">            response.print(&quot;&lt;body&gt;&quot;);</span><br><span class="line">            response.print(&quot;来而不往非礼也&quot;);</span><br><span class="line">            response.print(&quot;&lt;/body&gt;&quot;);</span><br><span class="line">            response.print(&quot;&lt;/html&gt;&quot;);</span><br><span class="line"></span><br><span class="line">            response.pushToBrowser(200);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (selectionKey.isReadable()) &#123;</span><br><span class="line">            Request request = new Request(selectionKey);</span><br><span class="line">        &#125;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h4><p>循环询问多路复用器的selectedKeys是否有值，等待连接事件<br>当有连接事件过来了，创建socketChannel<br>将socketChannel设置为非阻塞工作模式<br>将channel注册回selector上，监听<strong>可读事件</strong><br>创建Response并传入socketChannel，在Response里socketChannel.write();返回响应</p><p>如果是可读事件，把selectionKey传入Request解析请求，Request类首先selectionKey里获取socketChannel（就之前接入事件创建的socketChannel），然后创建byteBuffer，用于读取客户端请求信息。</p><h4 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h4><p>Selector、ServerSocketChannel本身为抽象类，不能直接创建,需要通过open()方法打开。<br>注意这段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (readyChannels == 0) &#123;</span><br><span class="line">           continue;&#125;</span><br></pre></td></tr></table></figure></p><p>最后献上教程，关于nio，<a href="http://www.imooc.com/learn/1118" target="_blank" rel="noopener">慕课有一个特别好的教程</a>，老师讲的很清楚。</p><h1 id="V3"><a href="#V3" class="headerlink" title="V3"></a>V3</h1><p>进行封装 request接受请求并打印。<br>response根据传入的状态码封装固定的头信息、推送响应信息。<br>server类只关心内容和状态码.</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java线程池详解</title>
      <link href="/2019/05/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/05/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h1><ol><li><strong>降低资源销毁</strong>。不用频繁的创建销毁线程，线程可以循环重复使用。</li><li><strong>提高响应速度</strong>。每当任务到达时，无需创建新线程。</li><li><strong>提高线程的可管理性</strong>。线程池可以统一分配、调优和监控。可以根据系统的承受能力，调整线程的数量，防止因为消耗过多内存导致服务器崩溃。</li></ol><h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><p>创建线程池有两种方法。一、构造方法创建。二、通过Executor框架的工具类Executors实现。</p><h2 id="一、构造方法创建"><a href="#一、构造方法创建" class="headerlink" title="一、构造方法创建"></a>一、构造方法创建</h2><p>在ThreadPoolExecutor类中提供了四个构造方法。</p><blockquote><p>public ThreadPoolExecutor(<strong>int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<runnable> workQueue</runnable></strong>);</p><p>   public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<runnable> workQueue,<strong>ThreadFactory threadFactory</strong>);</runnable></p><p>   public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<runnable> workQueue,<strong>RejectedExecutionHandler handler)</strong>;</runnable></p><p>   public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<runnable> workQueue,<strong>ThreadFactory threadFactory,RejectedExecutionHandler handler</strong>);</runnable></p></blockquote><h3 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h3><p>这里使用了上面构造方法的第一种进行创建一个线程池<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor threadPool= new ThreadPoolExecutor(</span><br><span class="line">        10, 15, 60, TimeUnit.SECONDS,new LinkedBlockingQueue&lt;Runnable&gt;(1024));</span><br></pre></td></tr></table></figure></p><p>第一个参数corePoolSize=10 表示这个线程池初始化了10个线程在里面工作<br>第二个参数maximumPoolSize=15 表示如果10个线程不够用了，就会自动增加到最多15个线程<br>第三个参数keepAliveTime=60 结合第四个参数TimeUnit.SECONDS，表示经过60秒，多出来的线程还没有接到活儿，就会回收，最后保持池子里就10个<br>第四个参数TimeUnit.SECONDS 第三参数的单位为秒，有7种静态属性。<br>第五个参数 new LinkedBlockingQueue() 用来放任务的集合。有三个选择   </p><ul><li>ArrayBlockingQueue;</li><li>LinkedBlockingQueue;</li><li>SynchronousQueue;<br>ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous。线程池的排队策略与BlockingQueue有关。</li></ul><p>另外，threadFactory：线程工厂，主要用来创建线程。</p><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>handler：表示当处理任务时的四种拒绝策略：</p><ul><li>ThreadPoolExecutor.AbortPolicy:丢弃任务并<strong>抛出RejectedExecutionException异常</strong>。</li><li>ThreadPoolExecutor.DiscardPolicy：丢弃任务（<strong>当前将要加入队列的任务</strong>），但是不抛出异常。</li><li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列<strong>最老的任务</strong>，然后重新尝试执行任务，即重复此过程。</li><li>ThreadPoolExecutor.CallerRunsPolicy：<strong>由调用线程处理该任务</strong></li></ul><h2 id="二、通过Executor框架的工具类Executors实现"><a href="#二、通过Executor框架的工具类Executors实现" class="headerlink" title="二、通过Executor框架的工具类Executors实现"></a>二、通过Executor框架的工具类Executors实现</h2><ul><li>newCachedThreadPool创建一个<strong>可缓存线程池</strong>，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。适合处理短时间工作任务。</li><li>newFixedThreadPool 创建一个<strong>定长线程池</strong>，可控制线程最大并发数，超出的线程会在队列中等待。</li><li>newScheduledThreadPool 创建一个<strong>定长线程池</strong>，支持<strong>定时或者周期性</strong>任务执行。</li><li>newSingleThreadExecutor 创建一个<strong>单线程化</strong>的线程池，它只会用唯一的工作线程来执行任务，如何有异常结束，会有另一个线程去取代它。保证所有任务<strong>按照指定顺序</strong>(FIFO, LIFO, 优先级)执行。</li><li>newWorkStealingPool:1.8版本出现，利用working-stealing算法，<strong>可窃取任务，并行处理</strong>，需要穿一个并行级别的参数，如果不传，则被设定为默认的CPU数量。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService c= Executors.newCachedThreadPool();</span><br><span class="line">ExecutorService f= Executors.newFixedThreadPool(3);</span><br><span class="line">ScheduledExecutorService s= Executors.newScheduledThreadPool(5);</span><br><span class="line">ExecutorService sin= Executors.newSingleThreadExecutor(); </span><br><span class="line">// 设置并行级别为2，即默认每时每刻只有2个线程同时执行</span><br><span class="line">ExecutorService m = Executors.newWorkStealingPool(2);</span><br></pre></td></tr></table></figure><h2 id="三、不要使用Executors默认创建线程池的方式"><a href="#三、不要使用Executors默认创建线程池的方式" class="headerlink" title="三、不要使用Executors默认创建线程池的方式"></a>三、不要使用Executors默认创建线程池的方式</h2><p>另外注意：不要使用Executors<strong>默认</strong>创建线程池的方式，这可能会导致OOM，因为LinkedBlockingQueue时未指定容量，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。是可以不断的向队列中加入任务的，这种情况下就有可能因为任务过多而导致内存溢出问题。<br>上面提到的问题主要体现在newFixedThreadPool和newSingleThreadExecutor两个工厂方法上，并不是说newCachedThreadPool和newScheduledThreadPool这两个方法就安全了，这两种方式默认创建的最大线程数可能是Integer.MAX_VALUE，而创建这么多线程，必然就有可能导致OOM。<br>反例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> ExecutorService executor = Executors.newFixedThreadPool(15);//不要这样做</span><br></pre></td></tr></table></figure></p><p>正例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = new ThreadPoolExecutor(</span><br><span class="line">10, 10,60L, TimeUnit.SECONDS,new ArrayBlockingQueue(10));</span><br></pre></td></tr></table></figure></p><h1 id="线程池类的社会关系"><a href="#线程池类的社会关系" class="headerlink" title="线程池类的社会关系"></a>线程池类的社会关系</h1><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p><code>ThreadPoolExecutor——&gt;AbstractExecutorService——&gt;ExecutorService——&gt;Executor</code><br>线程池类ThreadPoolExecutor在包java.util.concurrent下， 继承了AbstractExecutorService 抽象类，该抽象类实现了ExecutorService接口，而该接口继承了Executor接口</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>Executor是一个顶层接口，在它里面只声明了一个方法execute(Runnable)，返回值为void，参数为Runnable类型，从字面意思可以理解，就是用来执行传进去的任务的；<br>ExecutorService接口声明了一些方法：submit、invokeAll、invokeAny以及shutDown等；<br>抽象类AbstractExecutorService基本实现了ExecutorService中声明的所有方法；<br>在ThreadPoolExecutor类中有几个非常重要的方法：</p><ul><li>execute()</li><li>submit()</li><li>shutdown()</li><li>shutdownNow()</li></ul><p>execute()可以向线程池提交一个任务。<br>submit()也是用来向线程池提交任务的，但是它和execute()方法不的是能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果。<br>shutdown()和shutdownNow()是用来关闭线程池的。</p><h1 id="线程池的状态（5种）"><a href="#线程池的状态（5种）" class="headerlink" title="线程池的状态（5种）"></a>线程池的状态（5种）</h1><p>其中AtomicInteger变量ctl的功能非常强大：利用低29位表示线程池中线程数，通过高3位表示线程池的运行状态：<br>1、<strong>RUNNING</strong>：-1 &lt;&lt; COUNT_BITS，即高3位为111，该状态的线程池会接收新任务，并处理阻塞队列中的任务；<br>2、<strong>SHUTDOWN</strong>： 0 &lt;&lt; COUNT_BITS，即高3位为000，该状态的线程池不会接收新任务，但会处理阻塞队列中的任务；<br>3、<strong>STOP</strong> ： 1 &lt;&lt; COUNT_BITS，即高3位为001，该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；<br>4、<strong>TIDYING</strong> ： 2 &lt;&lt; COUNT_BITS，即高3位为010，该状态表示线程池对线程进行整理优化；<br>5、<strong>TERMINATED</strong>： 3 &lt;&lt; COUNT_BITS，即高3位为011，该状态表示线程池停止工作；</p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；<br>如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果阻塞队列满了，那就创建新的线程执行当前任务；<br>直到线程池中的线程数达到maxPoolSize,这时再有任务来，只能执行reject()处理该任务。</p><h1 id="如何合理配置线程池的大小？"><a href="#如何合理配置线程池的大小？" class="headerlink" title="如何合理配置线程池的大小？"></a>如何合理配置线程池的大小？</h1><p>根据《Java并发编程实战》对于计算密集型的任务，在拥有N个处理器的系统上，当线程池的大小为N+1时，通常能实现最优的效率。(即使当计算密集型的线程偶尔由于缺失故障或者其他原因而暂停时，这个额外的线程也能确保CPU的时钟周期不会被浪费。)</p><p>如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 <strong>NCPU+1</strong><br>如果是IO密集型任务（比如数据库数据交互、文件上传下载、网络数据传输等等），参考值可以设置为<strong>2*NCPU</strong><br><em>tips：这行代码可以查看Ncpu<br><code>System.out.println(Runtime.getRuntime().availableProcessors());//输出运行时可用处理器</code></em></p><blockquote><p>参考博文<br><a href="https://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">这篇比较详细，还有源码解读</a><br><a href="https://www.cnblogs.com/leipDao/p/8436380.html" target="_blank" rel="noopener">关于ThreadFactory与BlockingQueue</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自己实现简易线程池</title>
      <link href="/2019/05/26/%E8%87%AA%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2019/05/26/%E8%87%AA%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>线程池其实就是一个生产者消费者（bounded-buffer problem）,学了多线程不妨自己写一个简易的线程池。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>构造函数</strong>初始化固定数量的线程并启动。<br><strong>execute（）</strong>接受到一个任务线程，就锁住任务队列，把任务加入队列，然后唤醒所有在等待获取队列的线程。<br><strong>工作线程</strong>不断查询任务队列是否有任务，如果没有该线程等待，如果有任务，取出一个任务，唤醒所有在等待获取队列的线程，释放掉锁。执行任务线程的run方法。</p><p>线程池类重要元素</p><ul><li>任务容器，这里我们用链表存储</li><li>add方法，把任务线程放入任务容器（注意任务是一个有run方法的线程）</li><li>构造函数，接受corePoolSize参数生成固定数目线程</li></ul><p><em>2019年06月13号注：最近读书《java开发手册》OOP规约第11条：构造方法里禁止加入任何业务逻辑，如果有初始化逻辑，请放在init中。下面代码正好违背了这个规约。。。我这里也不改了，做个反例。在下一篇自实现线程池中有改进。</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package multiThread.threadPool;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line">public class ThreadPool &#123;</span><br><span class="line">    // 线程池大小</span><br><span class="line">    private int corePoolSize;</span><br><span class="line">    // 任务容器</span><br><span class="line">    private LinkedList&lt;Runnable&gt; workQueue = new LinkedList&lt;Runnable&gt;();</span><br><span class="line">    private volatile boolean RUNNING =true;</span><br><span class="line">    public ThreadPool(int corePoolSize) &#123;</span><br><span class="line">        //创建时候初始化线程</span><br><span class="line">        this.corePoolSize = corePoolSize;</span><br><span class="line">        synchronized (workQueue) &#123;</span><br><span class="line">            for (int i = 0; i &lt; corePoolSize; i++) &#123;</span><br><span class="line">                new Worker(&quot;线程&quot; + i).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //将任务线程放入线程池</span><br><span class="line">    public void execute(Runnable r) &#123;</span><br><span class="line">        synchronized (workQueue) &#123;</span><br><span class="line">            workQueue.addLast(r);</span><br><span class="line">            //放入后唤醒所有wait线程</span><br><span class="line">            workQueue.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Worker extends Thread &#123;</span><br><span class="line">        Runnable task;</span><br><span class="line">        public Worker(String name) &#123;</span><br><span class="line">            super(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //锁住任务队列，试图取任务，失败则该线程wait</span><br><span class="line">            while (RUNNING) &#123;</span><br><span class="line">                synchronized (workQueue) &#123;</span><br><span class="line">                    while (workQueue.isEmpty()) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            workQueue.wait();</span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    task = workQueue.removeLast();</span><br><span class="line">                    workQueue.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">                //取到线程即可释放锁</span><br><span class="line">                System.out.println(this.getName() + &quot;获得到并且开始执行任务&quot;);</span><br><span class="line">                task.run();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class TestThreadPool &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        //线程池大小初始化为3</span><br><span class="line">        ThreadPool threadPool=new ThreadPool(3);</span><br><span class="line">        //生成10个任务放入线程池</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">          Runnable task=  new Runnable()&#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    System.out.println(&quot;做任务中。。。&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">          threadPool.add(task);</span><br><span class="line">          Thread.sleep(1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>ConsumerThread类中这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">synchronized (tasks) &#123;</span><br><span class="line">  //试图取任务。。。</span><br><span class="line">&#125;</span><br><span class="line">//取到线程即可释放锁</span><br><span class="line">task.run();</span><br></pre></td></tr></table></figure></p><p>从任务中取任务时候是把任务队列锁住的，释放掉再去执行。如果不释放就去执行，那它执行的过程中其他线程都得等着，<strong>相当于一次只能有一个线程进行任务</strong>。</p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>1.我们是在构造函数创建线程，而java线程池只有当提交一个任务时，线程池才会创建一个新线程执行任务，直到当前线程数等于corePoolSize。这样会更节约资源。<br>2.这里我们用LinkedList加线程wait（）notify（）来实现，也可以像java线程池一样用阻塞链表LinkedBlockingQueue来实现。</p><p><a href="http://wangxuanni.top/2019/05/26/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">想进一步了解java线程池，可以看我上一篇博文</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>布隆过滤器</title>
      <link href="/2019/04/16/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2019/04/16/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>布隆过滤器应用于最近比较火的海量处理问题。可以快速判断一个元素在不在海量数据的集合当中。缺点是有一定的失误率，优势是占用内存较少。<br><a id="more"></a></p><h2 id="0一道大数据黑名单题"><a href="#0一道大数据黑名单题" class="headerlink" title="0一道大数据黑名单题"></a>0一道大数据黑名单题</h2><p>不安全网页的黑名单里有100亿个URL，每一个网页的URL最多占用64B。要求实现一种过滤系统，可以根据网页的URL判断是否在这个黑名单中。要求的额外的空间不能超过30GB。</p><h2 id="1布隆过滤器是什么？"><a href="#1布隆过滤器是什么？" class="headerlink" title="1布隆过滤器是什么？"></a>1布隆过滤器是什么？</h2><p>布隆过滤器本质上是一个bit数组，可以用极少的空间解决“判断在不在”这种问题。<br>以这道题为例，一般的思路是将所有的URL整个都存储起来，<strong>但是这个题目其实只需要我们判断在不在，我们根本无需存整个URL，甚至无需在意一个URL是多少字节，只需要存这个URL是“在”还是“不在”这两种状态就好了。</strong><br>讲到这里不知读者有没联想我们计算机世界的0和1。我们完全可以用一个容器存放这两种状态，在黑名单URL用1来表示，不在黑名单用0来表示。<br>接下来我们就使用布隆过滤器着手解决这道题。首先创建一个bit数组，数组里所有位置初始化都为0。然后100亿个URL每一个都做hash运算，每一次得出的结果在bit数组对应的下标位置把0变成1。有URL对应的数组位置会被我们“标记”。当100亿个URL改变了bit数组里对应位置的值后，就得到我们所需要的布隆过滤器。</p><p>重头戏来了，当我们需要判断一个URL在不在黑名单里，只需要判断URL在经过hash函数后对应的bit数组下标的位置是“0”还是“1”。<br>如果对应位置是0，意味这个位置仍是初始化状态，没有被标记过，所以这个URL不在黑名单里。如果对应位置是1，意味这个位置已经被标记过，所以这个URL在黑名单里。<br>讲到这里，读者可能已经有一个“布隆过滤器器就是一个bit数组的”模糊全局概念。因为以上描述只是为了让读者知道布隆过滤器是个啥。接下来，请看几个布隆过滤的重要知识点。</p><h2 id="2hash函数"><a href="#2hash函数" class="headerlink" title="2hash函数"></a>2hash函数</h2><p>上面所提到的“100亿个URL每一个都做hash运算”，这里的hash运算在实际中不只是一个hash函数，而是<strong>一组hash函数</strong>。顺便说一句hash函数不需要自己实现，经典的哈希函数已经有很多了，比如MD5、SHAI。<br>但为什么URL经过hash函数的出来的值一定会是bit数组下标？打个比方，一个最简单的hash运算：%3。集合里的数经过%3的hash运算后，是只可能得出0或1或2，这三种情况。也就是说hash运算得出的输出域是固定的。这是hash函数的一个重要性质：<strong>哈希函数有无限的输入域，但只有固定有限输出域。</strong></p><h2 id="3布隆过滤器误判类型"><a href="#3布隆过滤器误判类型" class="headerlink" title="3布隆过滤器误判类型"></a>3布隆过滤器误判类型</h2><p>布隆过滤器是有一定失误率。它的误判类型是——<strong>宁可错杀一百，也不能放过一个</strong>。也就是说如果URL在黑名单，判断结果一定会表示在。可能失误的情况是：某个URL不在黑名单里，也被判断在。<br>为什么布隆过滤器会失误？并且只会“冤枉”，不会“漏判”？这是因为hash函数的另一个性质：<strong>不同的输入值hash运算后得到的散列输出值可能不同</strong>，也可能相同。但是不同的散列输出值对应的输入值一定不同。<br>假如要判断的两个URLhash运算得到了相同的结果，但一个在黑名单里，一个不在黑名单里，对应的数组下标位置已经被描黑，那么两个URL都会被判为在黑名单里。</p><h2 id="4计算误判率"><a href="#4计算误判率" class="headerlink" title="4计算误判率"></a>4计算误判率</h2><p>误判率与数组长度、哈希函数的个数成负相关，与样本量成正相关。<br>举一个极端的例子，如果样本量很大而bit数组太小，经过100亿和URL的标记后，数组里的所有元素都被“描黑”。此时任意一个URL都会被判断在黑名单里。<br>想要减少失误率就需根据三个公式设计一个长度合适的bit数组。<br>还是上面那道题为例，n是样本量，即100亿；p预期失误率，即0.0001，m是数组元素个数。01<br>公式一：计算布隆过滤器的大小把p和n代入公式match，lnp等于-9.21，（ln2）的平方是0.7，n是100亿计算出来m等于19.19n，转为GB,等于bit数组大小要开25G02</p><p>公式二：我们还得确定hash函数的个数，哈希函数的个数k公式:算出k为14，需要14个hash函数03</p><p>公式三：计算失误率，p公式：算出失误率是0.006%。还是以上面那道题目为例，如果布隆过滤器的大小开25g，那么有0.006%的失误率，内存和失误率都满足要求。”</p><p>附注：这里本来有三张公式图的，但在markdown放图片太麻烦了，如果想看可以去<a href="https://mp.weixin.qq.com/s?__biz=MzUzNjk5NDk1OQ==&amp;mid=2247483707&amp;idx=1&amp;sn=fd9d8f04edc085a9d60511fd5513fd0d&amp;chksm=faecf4dbcd9b7dcd3dde98e71e2f447cdeb98f8b5c6a776eb7344c267bab6351c5cde169e527&amp;mpshare=1&amp;scene=1&amp;srcid=0429kbCkM8nl32g91u4cjwOE&amp;pass_ticket=o7Y28LwCkECdew2CB9ZmY%2BKd3rs%2BvSQamorjwZdBJfHahNMblqC42vSiDnvNcg%2F2#rd" target="_blank" rel="noopener">公众号推文上看。</a></p><h2 id="5扩展"><a href="#5扩展" class="headerlink" title="5扩展"></a>5扩展</h2><p>布隆过滤器可以解决许多问题，比如：<strong>网页URL的去重，缓存穿透，垃圾邮件的判别</strong>等问题。<br>这里重点介绍一下布隆过滤器如何解决缓存穿透的问题。<strong>缓存穿透</strong>，简单来说就是因为有海量的不存在的key请求，导致缓存起不了作用，大量请求引向数据库，导致数据库宕机。<br>当有人恶意攻击，把发起海量的不存在的key请求，由于都是不存在的请求，缓存自然查不到，这些海量的请求就会都会落到数据库中。导致数据库崩溃。<br>一般解决方案是：缓存空数据，如果某key数据库查询结果为空，则把这个不存在值的key也缓存起来，设置较短过期时间，当后续又出现该key时，就可以在缓存里查询到了，不再请求数据库。<br>但是如果有人恶意攻击，key是随机生存的，请求的key是大量而不重复，这样的做法就用处不大了。<br>用布隆过滤器解决：是请求过来，先调用布隆过滤器判断数据是否存在。如果不存在的数据，就不要把请求引向数据库。直接过滤掉了大量不存在的数据攻击。<br><strong>总的来说，当数据量比较大并且重复率不高的时候，布隆过滤器的成本比一般解决方案成本更低。</strong></p><h2 id="6练练手"><a href="#6练练手" class="headerlink" title="6练练手"></a>6练练手</h2><p>看了这篇文章，不如乘热打铁，做道题目看看感觉如何<br><u><em>题目：32位无符号整数的范围是0 - 4294967295，现在有一个正好包含40亿个无符号整数的文件，所以在整个范围中必然有没出现过的数。可以使用最多1GB的内存，怎么找到所有出现过两次的数？在看答案前，请自己试着做一做吧</em></u>！</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程基础概念</title>
      <link href="/2019/02/11/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/02/11/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>在学synchronized和volatile之前，我们先来了解一个概念——什么是线程安全？<br>线程安全简单来说就在多线程的情况下也不会有问题，看似一句废话，要怎么理解呢<br>比如ArrayList不是线程安全的就是一个线程不安全的类，<br>如果两个线程对可以同一个ArrayList进行add操作会出现什么结果？请看下面代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest &#123;</span><br><span class="line">            static List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            static class BB implements Runnable &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for (int j = 0; j &lt; 10000; j++) &#123;</span><br><span class="line">                        list.add(j);</span><br><span class="line">                    &#125; &#125; &#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException&#123;</span><br><span class="line"></span><br><span class="line">                BB b = new BB();</span><br><span class="line">                Thread t1 = new Thread(b);</span><br><span class="line">                Thread t2 = new Thread(b);</span><br><span class="line">                t1.start();</span><br><span class="line">                t2.start();</span><br><span class="line">                t1.join();</span><br><span class="line">                t2.join();</span><br><span class="line"></span><br><span class="line">                System.out.println(list.size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>问题出在add方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;   ensureCapacityInternal(size + 1);   </span><br><span class="line">elementData[size++] = e;  </span><br><span class="line">return true;&#125;</span><br></pre></td></tr></table></figure></p><p>上面的程序，可能有三种情况发生：</p><ul><li><p>数组下标越界。首先要检查容量，必要时进行扩容。每当在数组边界处，如果A线程和B线程同时进入并检查容量，也就是它们都执行完ensureCapacityInternal方法，因为还有一个空间，所以不进行扩容，此时如果A暂停下来，B成功自增；然后接着A从 elementData[size++]=e开始执行，由于A之前已经检查过没有扩容，而B成功自增使得现在没有空余空间了，此时A就会发生数组下标越界。</p></li><li><p>小于20000。size++可以看成是 size=size+1，这一行代码包括三个步骤，先读取size，然后将size加1，最后将这个新值写回到size。此时若A和B线程同时读取到size假设为10，B先自增成功size变11，然后回来A因为它读到的size也是10，所以自增后写入size被更新成11，也就是说两次自增，实际上size只增大了1。因此最后的size会小于200。</p></li><li>等于20000 很幸运，没有发生上面情况<br>顺便说一句，线程越多，或者加的数越大越可能出现不安全的问题</li></ul><h2 id="synchronized：“这条桥上一次只能过一个人”"><a href="#synchronized：“这条桥上一次只能过一个人”" class="headerlink" title="synchronized：“这条桥上一次只能过一个人”"></a>synchronized：“这条桥上一次只能过一个人”</h2><p>synchronized保证了当有<strong>多个线程同时操作共享数据时，任何时刻只有一个线程能进入临界区操作共享数据，其他线程必须等待。</strong><br>它可以保证操作的<strong>原子性</strong>synchronized通过<strong>同步锁</strong>保证线程安全，进入临界区前必须获得对象的锁，其他没有获得锁的线程不可进入。当临界区中的线程操作完毕后，它会释放锁，此时其他线程可以竞争锁，得到锁的那个线程便可以进入临界区。<br>synchronized还可以保证<strong>可见性</strong>。因为对一个变量的unlock操作之前，必须先把次变量同步回主内存中。它还可以保证有序性，因为一个变量在任何时刻只能有一个线程对其进行lock操作（也就是任何时刻只有一个线程可以获得该锁对象），这决定了持有同一把锁的两个同步块只能串行进入。</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile是一个关键字，用于修饰变量。被其修饰的变量具有可见性和有序性。<br><strong>可见性</strong>，当一条线程修改了这个变量的值，新值能被其他线程立刻观察到。具体来说，volatile的作用是：在本CPU对变量的修改直接写入主内存中，同时这个写操作使得其他CPU中对应变量的缓存行无效，这样其他线程在读取这个变量时候必须从主内存中读取，所以读取到的是最新的，这就是上面说得能被立即“看到”。<br><strong>有序性</strong>，即volatile可以<strong>禁止指令重排</strong>。volatile在其汇编代码中有一个lock操作，这个操作相当于一个内存屏障，指令重排不能越过内存屏障。具体来说在执行到volatile变量时，内存屏障之前的语句一定被执行过了且结果对后面是已知的，而内存屏障后面的语句一定还没执行到；在volatile变量之前的语句不能被重排后其之后，相反其后的语句也不能被重排到之前。</p><h2 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h2><p>一个非常典型性的线程交互的问题。</p><ol><li>使用栈来存放数据<br>1.1 把栈改造为支持线程安全<br>1.2 把栈的边界操作进行处理，当栈里的数据是0的时候，访问pull的线程就会等待。 当栈里的数据是200的时候，访问push的线程就会等待</li><li>提供一个生产者（Producer）线程类，生产随机大写字符压入到堆栈3. 提供一个消费者（Consumer）线程类，从堆栈中弹出字符并打印到控制台</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2019/01/21/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/01/21/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式的三要素"><a href="#单例模式的三要素" class="headerlink" title="单例模式的三要素"></a>单例模式的三要素</h1><ol><li>构造方法私有化</li><li>静态属性修饰的实例</li><li>public static的 getInstance方法，返回第二步实例引用</li></ol><h1 id="单例模式的四种写法"><a href="#单例模式的四种写法" class="headerlink" title="单例模式的四种写法"></a>单例模式的四种写法</h1><h2 id="饿汉单例模式"><a href="#饿汉单例模式" class="headerlink" title="饿汉单例模式"></a>饿汉单例模式</h2><p>先创建一个实例等着调用<br><figure class="highlight plain"><figcaption><span>class GiantDragon &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    //私有化构造方法使得该类无法在外部通过new 进行实例化</span><br><span class="line">    private GiantDragon()&#123;  &#125;</span><br><span class="line"> </span><br><span class="line">    //准备一个类属性，指向一个实例化对象。 因为是类属性，只有一个并且不需要实例即可使用</span><br><span class="line">    private static GiantDragon instance = new GiantDragon();</span><br><span class="line">     </span><br><span class="line">    //public static 方法，提供给调用者获取12行定义的对象</span><br><span class="line">    public static GiantDragon getInstance()&#123;</span><br><span class="line">        return instance;&#125;</span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line">            GiantDragon g1 = GiantDragon.getInstance();</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>优点：1.线程安全<br>缺点1.可能造成浪费，无论是否会用到这个对象，都会加载。<br>2.还有一个漏洞，别人可以通过反射的方式创建一个新对象。</p><h2 id="懒汉单例模式"><a href="#懒汉单例模式" class="headerlink" title="懒汉单例模式"></a>懒汉单例模式</h2><p>只有在调用getInstance的时候，才会创建实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class GiantDragon &#123;</span><br><span class="line">    //私有化构造方法使得该类无法在外部通过new 进行实例化</span><br><span class="line">    private GiantDragon()&#123;       </span><br><span class="line">    &#125;</span><br><span class="line">      //准备一个类属性，用于指向一个实例化对象，但是暂时指向null</span><br><span class="line">    private static GiantDragon instance;</span><br><span class="line">     </span><br><span class="line">    //public static 方法，返回实例对象</span><br><span class="line">    public static GiantDragon getInstance()&#123;</span><br><span class="line">        //第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象</span><br><span class="line">        if(null==instance)&#123;</span><br><span class="line">            instance = new GiantDragon();</span><br><span class="line">        &#125;</span><br><span class="line">        //返回 instance指向的对象</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意这样写是线程不安全的！</strong><br>问题出在直接“if(null==instance){”判断实例为null，就创建对象。<br>为什么说是线程不安全的呢。请模拟一下两个线程同时来创建对象结果会发生什么？<br>如果两个对象同时判断为空，结果就会创造了两个实例，就不是单例模式啦。<br>因此加入<strong>synchronized声明</strong>。<br>但如果判断语句写在同步代码后面，导致同步块包括了判断语句，这并没有必要，最重要的是很影响速度。（代码如下）<br><code>synchronized (Singleton.class) {            if (instance == null) {</code><br>如果在同步代码写在判断语句前面，可能会出现两个线程同时判断都为空，才进入同步块，线程1创建完一个对象后，线程2还会创造一个对象，只是两个线程创建对象不是同时发生而已，并没有解决线程不安全问题（代码如下）<br><code>if (instance == null) {            synchronized (Singleton.class){</code><br>重点来了，可以用<strong>双重检测机制</strong>，即在synchronized声明前后都判断一次是否为空，保证线程安全。<br>如果没有第一个判断：所有调用这个方法的线程都得先获取锁，不管此时实例是否为空，有没有必要。<br>如果没有第二个判断：如果两个线程同时判断为空，一个先取锁，一个后取锁。还是会创建两个对象，只不过是一个先一个后。第二个判断避免了两个线程<strong> 同时判断为空 </strong>先后获取锁创建对象的情况.线程1创建完实例后，线程2再执行的时候要经过第二次判断，此时已经有实例了，线程2就不满足创建条件。<br>双重检测机制不会影响效率。因为在第一次判断语句不是在同步块内，并没有影响多少效率。<br>第二次判断虽然在同步块内，但只有当实例为空的时候需要获取锁。</p><p>另外，实例是非原子性的，有可能出现<strong>指令重排问题</strong>，因此实例用<strong>volatile</strong>修饰。<br><figure class="highlight plain"><figcaption><span>class Singleton &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static volatile Singleton instance = null;</span><br><span class="line">private Singleton()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">public static Singleton getInstance() &#123;</span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">        synchronized (Singleton.class)&#123;</span><br><span class="line">            if (instance == null) &#123;</span><br><span class="line">                instance = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance; &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>懒汉式优点：相对于饿汉模式；来说在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。<br>懒汉式缺点：1.麻烦，需要我们来自己加锁，保证线程安全的问题。<br>2.还是可以通过反射的方式来破坏单例模式。</p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton3 &#123;</span><br><span class="line">    //静态内部类</span><br><span class="line">    private static class LazyHolder&#123;</span><br><span class="line">        private static Singleton3 instance = new Singleton3();</span><br><span class="line">    &#125;</span><br><span class="line">    //私有构造器</span><br><span class="line">    private Singleton3()&#123;&#125;;</span><br><span class="line">    public static Singleton3 getInstance() &#123;</span><br><span class="line">        return LazyHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<strong>外部类无法访问静态内部类</strong>，因此只有当外部类调用Singleton.getInstance()方法的时候，才能得到instance实例。并且，instance实例对象初始化的时机并不是在Singleton被加载的时候，而是当getInstance()方法被调用的时候，静态内部类才会被加载，这时instance对象才会被初始化。并且也是线程安全的。所以，与饿汉式相比，通过静态内部类的方式，可以保证instance实例对象不会被白白浪费。但是，它仍然存在反射问题。<br>优点：1.线程安全<br>2.不会浪费<br>缺点：还是反射问题</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton4 &#123;   </span><br><span class="line">instance;&#125;</span><br></pre></td></tr></table></figure><p>枚举方式优点：1.线程安全<br>2.代码简单<br>3.反射也不能获得多个对象，因为JVM能阻止反射获取枚举类的私有构造器<br>枚举方式缺点：和饿汉式一样，由于一开始instance实例就被创建了，所以有可能出现白白浪费的情况。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/2019/01/20/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/01/20/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><blockquote><p>一个场景设定，假设你要结婚了，但你不会为了结婚就要学婚礼布置，拍婚纱照等技术活，这些可以交给婚庆公司做嘛。于是你找了婚庆公司作为你的代理为了做一些准备工作。但最后去结婚的是你而不婚庆公司。这就是代理模式了。</p></blockquote><h2 id="静态代理有三个元素：共同接口、代理对象、目标对象。"><a href="#静态代理有三个元素：共同接口、代理对象、目标对象。" class="headerlink" title="静态代理有三个元素：共同接口、代理对象、目标对象。"></a>静态代理有三个元素：共同接口、代理对象、目标对象。</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Marry &#123;</span><br><span class="line">    void marry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代理类，把接口当做参数传入构造函数中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class MarryCompany implements Marry &#123;</span><br><span class="line">    Marry marry;</span><br><span class="line"></span><br><span class="line">    public MarryCompany(Marry marry) &#123;</span><br><span class="line">        this.marry = marry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void proWwork() &#123;</span><br><span class="line">        System.out.println(&quot;婚礼前准备&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void afterWwork() &#123;</span><br><span class="line">        System.out.println(&quot;婚礼后收拾&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void marry() &#123;</span><br><span class="line">        proWwork();</span><br><span class="line">        marry.marry();</span><br><span class="line">        afterWwork();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>目标对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class You implements Marry&#123;</span><br><span class="line">    public void marry()&#123;</span><br><span class="line">        System.out.println(&quot;我结婚了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Marry marry=new MarryCompany(new You());</span><br><span class="line">        marry.marry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><u>静态代理不实现接口也能做到，为什么还要实现共同接口？</u>接口的作用是保证了代理对象具有和被代理对象具有一样的契约。<br>“代理”是针对相同的接口编程，以达到透明地替换原来的对象。如果添加一个不相干新的类去做这件事，这叫委托模式了。</p><h2 id="静态代理总结"><a href="#静态代理总结" class="headerlink" title="静态代理总结:"></a>静态代理总结:</h2><p>优点：可以做到在不修改目标对象的功能前提下,对目标功能扩展.<br>缺点:因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护。此时动态代理闪亮登场！</p><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>在动态代理中我们不再需要再手动的创建代理类，我们只需要编写一个动态处理器就可以了。真正的代理对象由JDK再运行时为我们动态的来创建。<br>比如这次不是我结婚了，而是我的宠物猫jack和rose要举行婚礼</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>待完善</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《java web开发与应用》笔记</title>
      <link href="/2018/12/17/%E3%80%8Ajava%20web%E5%BC%80%E5%8F%91%E4%B8%8E%E5%BA%94%E7%94%A8%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/12/17/%E3%80%8Ajava%20web%E5%BC%80%E5%8F%91%E4%B8%8E%E5%BA%94%E7%94%A8%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="从C-S从到B-S"><a href="#从C-S从到B-S" class="headerlink" title="从C/S从到B/S"></a>从C/S从到B/S</h1><p>C/S即客户机/服务器，比如qq电脑版。B/S即浏览器/服务器，比如京东网页版。<br>◆问:C/S有哪些不足?<br>答:qq客户端有丰富的功能,网络上传递的一般只是数据本身,客户端收到数据之后,负责处理这些数据并进行显示。不过如果qq更新了一个钱包功能,必须通知客户端更新，就是我们平时经常跳出的更新提示。<br>◆问:如何解决这个间题?<br>解决办法实际上很简单:让界面的显示效果在服务器端生成,传给客户端;服务器传什么,客户端就显示什么,客户端不要参与太多数据处理。这样,管理员如果想内容修改了,也不需要通知客户端升级,客户端只需要安装负责显示的软件（浏览器）,就可以了。<br>◆问:如何实现?<br>B/S模式。也分为客户机和服务器两层,但是客户机上不用安装软件,只需要使用浏览器即可,网络上传输的也不再是普通数据,而是将这些数据用HTML等技术进行处理之后的结果。<br>而Web网站最基本的要求是:必须使客户能够通过HTTP访问网站中的网页。比如,输人<a href="http://www.google.com,可以打开Google页面,说明Google就是Web网站。" target="_blank" rel="noopener">http://www.google.com,可以打开Google页面,说明Google就是Web网站。</a><br>怎样让用户能通过HTTP访问网页呢?很简单,只需将网页放在服务器中运行。当然,此处所讲的服务器是软件服务器（比如Tomcat）,不是硬件服务器。</p><p>Cookie原理<br>Cookie翻译成中文是“小甜饼”的意思,它能够使客户在登录过程中摆脱烦琐的输入账号和密码的过程。 Cookie的原理如下<br>(1)当用户登录成功后,服务器将其登录信息(如账号、密码)保存在客户端硬盘上的一个小文件内。<br>(2)下次用户访问该网站,浏览器读取该小文件(即 Cookie)中的信息(如账号、密码)传给服务器。<br>(3)服务器对这些信息进行验证,如果验证通过,跳转到登录成功的页面。<br>注意：cookie是保存在客户端。并且下次登录不需要输入账号、密码,并不代表账号、密码不需要在服务器端验证。</p><h1 id="MVC思想"><a href="#MVC思想" class="headerlink" title="MVC思想"></a>MVC思想</h1><p>想象一下，你用jsp为学校做好了一个学校教务系统。<br>有一天，学校突然决定,选课表单显示应该更美观一些,要改变显示方法。<br>由于计算机犯罪越来越多,要求在验证信息的时候多一些功能,如安全密钥等。<br>数据库迁移,数据库变成了不同的名字,表结构也改变了,查询时需要修改代码。<br>要解决这些问题,就必须把JSP的某一部分改掉。但是,编写代码时最忌讳的就是在很长的一段程序中修改很小的一部分,这样做代价很高,并且在开发过程中分工也很不方便。如:因此,该方案中,将页面设计和商业逻辑混合在一起,在修改时必须读懂所有代码。从网页编写者的角度讲，希望看到的是大量的标签而不是java。而编程人员也需要知道数据库的结构。美工人员修改显示方法时,需要面对大量数据库访问代码。，开发时bu便于分工。<br>基于该问题,可以将该JSP拆成三个模块来实现。<br>首先,编写JSP,负责输入查询代码,提交到 Servlet,。Servlet进行安全验证,调用DAO来访问数据库,得到结果,跳转到JSP显示这种方法。<br>虽然前期设计比较复杂,但有如下特点<br>1、适合分工,每一个程序员只需要关心他自己所需要关心的那个模块。<br>2、维护方便,比如需要修改其中的一个部分,就对相应的模块进行修改就可以了。<br>对比这两种方案,可以发现,第二种方案把程序分为不同的模块,显示、业务逻辑、过程控制都独立起来,使得软件在可伸缩性和可维护性方面有了很大的优势。如要改变外观显示,只需要修改JSP就可以了;修改验证方法,只需要修改 Servlet就可以了;数据库迁移,只需要修改DAO就可以了。这种思想就是MVC思想。</p><h1 id="获取单选、双选、下拉菜单数据"><a href="#获取单选、双选、下拉菜单数据" class="headerlink" title="获取单选、双选、下拉菜单数据"></a>获取单选、双选、下拉菜单数据</h1><h2 id="单选"><a href="#单选" class="headerlink" title="单选"></a>单选</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">性别：</span><br><span class="line">男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;boy&quot; &gt;</span><br><span class="line">女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;girl&quot;&gt;</span><br></pre></td></tr></table></figure><p>获取数据代码略</p><h2 id="多选"><a href="#多选" class="headerlink" title="多选"></a>多选</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">唱歌&lt;input name=&quot;fav&quot; type=&quot;checkbox&quot; value=&quot;singing&quot;&gt;</span><br><span class="line">跳舞&lt;input name=&quot;fav&quot; type=&quot;checkbox&quot; value=&quot;dance&quot;&gt;</span><br><span class="line">打球&lt;input name=&quot;fav&quot; type=&quot;checkbox&quot; value=&quot;ball&quot;&gt;</span><br><span class="line">打游戏&lt;input name=&quot;fav&quot; type=&quot;checkbox&quot; value=&quot;game&quot;&gt;</span><br><span class="line">//注意4个多选input的name都为“fav”</span><br><span class="line">获取数据代码:</span><br><span class="line">&lt;%String [] fav=request.getParameterValues(&quot;fav&quot;);</span><br><span class="line">for (String s : fav) &#123;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%=s%&gt;</span><br><span class="line">&lt;% &#125;%&gt;</span><br></pre></td></tr></table></figure><h2 id="下拉菜单"><a href="#下拉菜单" class="headerlink" title="下拉菜单"></a>下拉菜单</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select name=&quot;home&quot;&gt;</span><br><span class="line">&lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;</span><br><span class="line">&lt;option value=&quot;&quot;&gt;上海&lt;/option&gt;</span><br><span class="line">&lt;option value=&quot;&quot;&gt;广州&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>获取数据代码略</p><h1 id="jsp有些功能用-JavaScript也能够实现-那有何区别"><a href="#jsp有些功能用-JavaScript也能够实现-那有何区别" class="headerlink" title="jsp有些功能用 JavaScript也能够实现,那有何区别?"></a>jsp有些功能用 JavaScript也能够实现,那有何区别?</h1><p>答:最大的区别是, Java Script源代码是被服务器发送到客户端,由客户端执行,因此,客户端可以看到 JavaScript源代码;而Java代码却不会。你在开发者工具查看代码是看不到jsp页面中的Java代码的。</p><h1 id="为什么需要url传值？"><a href="#为什么需要url传值？" class="headerlink" title="为什么需要url传值？"></a>为什么需要url传值？</h1><p>比如教务系统中，每个学生信息后面的删除按钮。点击之后会跳转到删除操作页面。但如何知道要删除哪个学生呢？这就需要在url跳转的时候顺便把要删除的学生学号传过去。当然，也可以传给本页面。<br><a href="delete.jsp?sno=1">删除</a><br><a href="delete.jsp?sno=2">删除</a><br>再比如说，让你写一个页面，上有10个链接，分别是1 2 3 4 5 6 7 8 9 10，单击相应的链接，在底部打印相应的乘法表。如点击4打印四四乘法表。url传值就派上用场了。<br>如果传值是中文会出现乱码问题，传值和取值支付URLEncoder.encode()和URLEncoder.decode()分别进行编码和解码</p><h1 id="为什么需要include指令？"><a href="#为什么需要include指令？" class="headerlink" title="为什么需要include指令？"></a>为什么需要include指令？</h1><p>比如版权信息，你不可能每个页面每个页面的复制吧，如果有变动岂不是每个都要改？</p><h1 id="include指令和include动作的区别"><a href="#include指令和include动作的区别" class="headerlink" title="include指令和include动作的区别"></a>include指令和include动作的区别</h1><p>&lt;%@include file=”info.jsp”%&gt;include指令不会实时更新<br>&lt;jsp:include page=”info.jsp” /&gt;include动作会实时更新<br>include指令在JSP编译时就将对应的文件包含进来。而 include动作则不同,其会在客户端对JSP文件发出请求的时候将对应包含文件的输出包含进来。include动作还会自动检查被包含文件的变化。也就是说,当被包含资源的内容发生<br>变化的时候,使用 include指令的话,服务器可能不会检测到,所以不会对其进行重新的编译,这给维护带来了巨大的麻烦。include动作则可以在每次客户端发出请求时重新把资源包含进来,进行实时的更新。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>URL传值会在浏览器的地址栏中看到传递的信息;<br>隐藏表单会在客户端页面的源代码中看到传递的信息;<br>Cookie会在客户端页面的文本文件中看到传递的信息。</p><p>检查用户提交的信息是否为空，可以用javascript实现。比如验证是否包含非法字符%，只要客户端检查输入就好了。<br>问：那如何检查用户<strong>所有</strong>输入是否有非法字符？<br>答：用循环获得所有表单数据。</p><p>jsp内置对象是自动载入的，因此它们不需要直接实例化。</p><p>请求服务器的端口号的方法，可以做类似“检查IP以220开头的用户是非法用户”的事情。</p><p>web.xml可以设置欢迎页<welcome-file-list></welcome-file-list></p><p>servlet为了实现控制者这一角色，必须要能够实现跳转。</p><p>过滤器可以判断用户类型，管理员、普通用户。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>javaSE（下）</title>
      <link href="/2018/10/10/javaSE%E4%B8%8B/"/>
      <url>/2018/10/10/javaSE%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="当finally中有返回语句"><a href="#当finally中有返回语句" class="headerlink" title="当finally中有返回语句"></a>当finally中有返回语句</h2><p>当try和finally中都有有返回语句会执行哪一个？<br>请看下面代码，猜猜程序的运行结果是？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static int testFinally() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(&quot;execute finally&quot;);</span><br><span class="line">            return 3;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int result = testFinally();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序在执行try中遇到return语句时，会先将返回值储存到一个指定位置，然后执行finally代码块。（除非碰到exit(0)函数，就直接结束不执行finally）<br>如果finally里面有返回语句将会覆盖其它返回语句，最终执行finally的return语句，储存中的return语句被回收。<br>如果finally 没有返回语句，则执行完finally按储存中的return来。<br>因此运行结果是:execute finally 3</p><h2 id="常见的runtime-exception-运行时异常-："><a href="#常见的runtime-exception-运行时异常-：" class="headerlink" title="常见的runtime exception(运行时异常)："></a>常见的runtime exception(运行时异常)：</h2><p>(不是必须进行try catch的异常 )<br>NullPointerException 空指针异常<br>ArithmeticException 算术异常，比如除数为零<br>ClassCastException 类型转换异常<br>ConcurrentModificationException 同步修改异常，遍历一个集合的时候，删除集合的元素，就会抛出该异常<br>IndexOutOfBoundsException 数组下标越界异常<br>NegativeArraySizeException 为数组分配的空间是负数异常</p><h2 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h2><p>举个栗子<br>throw是语句抛出一个异常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;abc&quot;; </span><br><span class="line">if(s.equals(&quot;abc&quot;)) &#123; </span><br><span class="line">  throw new NumberFormatException(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>throws是方法可能抛出异常的声明<br><code>public static void function() throws NumberFormatException{</code></p><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul><li>Java容器类类库的用途是”保存对象”，并将其划分为两个不同的概念：<br>1) Collection<br>一组”对立”的元素，通常这些元素都服从某种规则<br>　　1.1) List必须保持元素特定的顺序<br>　　1.2) Set不能有重复元素<br>　　1.3) Queue保持一个队列(先进先出)的顺序<br>2) Map<br>一组成对的”键值对”对象</li></ul><ul><li>Collection与Collections<br>Collection是所有集合类的根接口；<br>Collections是提供集合操作的工具类；常用方法如下<br>reverse    反转<br>shuffle    混淆<br>sort    排序<br>swap    交换（交换0和5下标的数据后）<code>Collections.swap(numbers,0,5);</code><br>rotate    滚动(把集合中的数据向右滚动2个单位)     <code>Collections.rotate(numbers,2);</code><br>synchronizedList    线程安全化</li></ul><h2 id="常用集合"><a href="#常用集合" class="headerlink" title="常用集合"></a>常用集合</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>代码展示ArrayList常用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;String&gt; animal = new ArrayList&lt;String&gt;();</span><br><span class="line">    //增</span><br><span class="line">    animal.add(&quot;松鼠&quot;);</span><br><span class="line">    animal.add(1, &quot;花猪&quot;);</span><br><span class="line">    //删</span><br><span class="line">    animal.remove(0);</span><br><span class="line">    animal.remove(&quot;花猪&quot;);</span><br><span class="line">    //查</span><br><span class="line">    System.out.println(animal.get(1));//根据位置获取对象</span><br><span class="line">    System.out.println(animal.indexOf(&quot;松鼠&quot;));//查对象的位置</span><br><span class="line">    //改</span><br><span class="line">    animal.set(0, &quot;猫&quot;);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //获取大小</span><br><span class="line">    System.out.println(animal.size());</span><br><span class="line">    </span><br><span class="line">    //判断是否包含</span><br><span class="line">    System.out.println(animal.contains(&quot;小狗&quot;));</span><br><span class="line">    </span><br><span class="line">    //把另一个容器所有对象都加进来</span><br><span class="line">    ArrayList human = new ArrayList();</span><br><span class="line">    animal.addAll(human);</span><br><span class="line">    </span><br><span class="line">    //转为数组，类型要是一样的哦</span><br><span class="line">    String[] array = new String[animal.size()];</span><br><span class="line">    animal.toArray(array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="IO流（待完善）"><a href="#IO流（待完善）" class="headerlink" title="IO流（待完善）"></a>IO流（待完善）</h1>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>javaSE（上）</title>
      <link href="/2018/10/06/javaSE%E4%B8%8A/"/>
      <url>/2018/10/06/javaSE%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="封装、继承、多态"><a href="#封装、继承、多态" class="headerlink" title="封装、继承、多态"></a>封装、继承、多态</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>访问修饰权限：<br>private（私有）, default（同一包）, public（共有）, protected（同一包和子孙类）<br>如果不写修饰符默认用default（package/friendly）修饰。<br><strong>default和protected区别：protected能访问子孙类，default不能。</strong><br><strong>会被子类继承的方法，通常使用protected</strong></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>接口和抽象类的主要区别？<br>从概念上来说<br>抽象类是一种对<strong>事物的抽象</strong>，而接口就像是一种约定，是一种对<strong>行为</strong>的抽象；<br>抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。<br>抽象类是一种模板式设计，而接口是一种<strong>行为规范</strong>，是一种辐射式设计。</p><p>模板式设计：如果B和C都使用了公共模板A，如果他们的公共部分需要改动，那么只改动A就可以了；<br>辐射式设计：如果B和C都实现了公共接口A，如果现在要向A中添加新的方法，那么B和C都必须进行相应改动。</p><p>区别1：<br><strong>一个类只能继承一个父类。<br>一个类可以实现多个接口</strong></p><p>区别2：<br>抽象类可以定义<br>public,protected,package,private、静态和非静态属性、final和非final属性<br>但是接口中声明的属性，只能是public、静态、final的</p><p>问题：Override(重写)和Overload(重载)的区别?Overload能改变返回值类型吗?</p><p>子类<strong>重写</strong>父类方法：子类的方法名与父类的一样，但是参数类型不一样。<br>重载：<strong>本类</strong>中出现的方法名一样，参数列表不同的方法。<br>与返回值类型无关。</p><p>思考：如果没有重写这样的机制，会发生什么？<br>答：一旦继承了父类，<strong>所有方法都不能修改了</strong>。另外，对象调用方法的时候，先找子类本身的方法，再找父类。(就近原则)</p><p>隐藏，就是子类覆盖父类的<strong>类方法</strong>。（重写是子类覆盖父类的对象方法 ）</p><p>为什么Java语言不支持c++所有的多重继承?<br>多重继承有它的弊端。<br>1)多重继承存在<strong>二义性</strong>。比如，类C同时继承类A和类B,如果类A和类B中都有方法f,那么调用类C的的f方法时,无法确定是调用类A还是类B的方法,将会产生二义性。但是Java语言却可以通过实现多个接口的方式间接地支持多重继承,由于接口只有方法体,没有方法实现,假设类C实现了接口A和接口B，即使AB都有f方法，但接口只有定义没有实现，在C中才有一个方法的实现，也就不存在二义性了。<br>2）多重继承会使得类型转换，构造方法的调用顺序变得非常复杂。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p><strong>操作符</strong>的多态<br>加号+可以作为算数运算，也可以作为字符串连接。不同情境下，具备不同的作用<br>如果+号两侧都是整型，那么+代表数字<strong>相加</strong><br>如果+号两侧，任意一个是字符串，那么+代表<strong>字符串连接</strong></p><p><strong>类</strong>的多态 比如<strong>父类的引用指向子类的对象</strong>、重写。</p><p><u>下面程序的运行结果是？</u><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">    int num = 1;</span><br><span class="line">    public Base()&#123;</span><br><span class="line">        this.print();</span><br><span class="line">        num=2;</span><br><span class="line">    &#125;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;Base.num=&quot;+num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Sub extends Base&#123;</span><br><span class="line">    int num= 3;</span><br><span class="line">    public Sub()&#123;</span><br><span class="line">        this.print();</span><br><span class="line">        num=4;</span><br><span class="line">    &#125;</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        System.out.println(&quot;Sub.num=&quot;+num);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test1 &#123;</span><br><span class="line">  public static void main(String[] args)</span><br><span class="line">  &#123;</span><br><span class="line">      Base b = new Sub();</span><br><span class="line">      System.out.println(b.num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在执行语句 Base b= new Sub时,会首先调用父类的构造方法。<strong>根据多态的特性,此时实例化的是sub类的对象,因此,base构造方法会调用Sub类的print()方法。由于此时Sub类中的初始化代码 Int num=3还没有执行,num的默认值为0,输出为 Sub num=0。</strong> 下一条语句父类num初始化为2。<br>然后会调用子类的构造方法,根据初始化的顺序可知在调用子类构造方法时,非静态的变量会先执行初始化动作,所以,此时子类Sub的mum值为3,因此,调用 print方法会输出 Sub num=3。<br>接着输出b.num,由于b的类型为Base,<strong>而属性没有多态的概念</strong>因此,此时会输出父类中的mm值:2<br>程序的运行结果如下：<br>Sub.num=0<br>Sub.num=3<br>2</p><p>题目总结：1.当父类的引用指向子类的对象时，会先初始化父类。<br>2.如果子类重写某方法，不管父类子类都是调用子类方法。<br>3.属性没有多态的概念。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="java初始化原则"><a href="#java初始化原则" class="headerlink" title="java初始化原则"></a>java初始化原则</h3><h3 id="对象属性初始化方法有3种"><a href="#对象属性初始化方法有3种" class="headerlink" title="对象属性初始化方法有3种"></a>对象属性初始化方法有3种</h3><ol><li>声明该属性的时候初始化 </li><li>构造方法中初始化</li><li>初始化块</li></ol><p>如果同时初始化同一变量，则优先级是：构造方法中初始化&gt;初始化块&gt; 声明该属性的时候初始化 </p><p>静态成员变量&gt;成员变量&gt;构造方法。<br>1静态变量优先与非静态变量<br>2父类优先于子类<br>3按照成员变量定义的顺序。<br>父子类的初始化执行顺序如下：<br>父类静态变量，父类静态代码块<br>子类静态变量，子类静态代码块<br>父类非静态变量，父类非静态代码块，父类构造方法<br>子类非静态变量，子类非静态代码块和子类构造函数。</p><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p> this关键字代表自身实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//参数名和属性名一样</span><br><span class="line">   //在方法体中，只能访问到参数name</span><br><span class="line">   public void setName1(String name)&#123;</span><br><span class="line">       name = name;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   //为了避免setName1中的问题，参数名不得不使用其他变量名</span><br><span class="line">   public void setName2(String heroName)&#123;</span><br><span class="line">       name = heroName;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   //通过this访问属性</span><br><span class="line">   public void setName3(String name)&#123;</span><br><span class="line">       //name代表的是参数name</span><br><span class="line">       //this.name代表的是属性name</span><br><span class="line">       this.name = name;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h3 id="实参与行参的问题"><a href="#实参与行参的问题" class="headerlink" title="实参与行参的问题"></a>实参与行参的问题</h3><p><u>猜一猜程序运行结果</u><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public void change(int j, StringBuffer ss1) &#123;</span><br><span class="line">        j = 100;</span><br><span class="line">        ss1.append(&quot;world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 1;</span><br><span class="line">        StringBuffer s1 = new StringBuffer(&quot;hello &quot;);</span><br><span class="line">        Test t = new Test();</span><br><span class="line">        t.change(i, s1);</span><br><span class="line">        System.out.println(i);//1处</span><br><span class="line">        System.out.println(s1);//2处</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于i是基本类型，因此参数是<strong>按值</strong>传递。<strong>会创建一个i的副本</strong>。把这个副本作为参数赋值给j。既然j是i的副本，那么对副本的任何修改都不会对i有影响。因此1处输出1。<br>由于StringBuffer是一个类，因此是按<strong>引用</strong>传递。当ss1修改的时候。由于实参s1和形参ss1指向的是同一块储存空间，因此ss1修改了值之后，s1指向的字符串也被修改了。因此2处输出hello world。<br>那么，下面程序运行结果又是什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public void change(StringBuffer ss1) &#123;</span><br><span class="line">       ss1 = new StringBuffer(&quot;world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">   StringBuffer s1 = new StringBuffer(&quot;hello &quot;);</span><br><span class="line">        Test t = new Test();</span><br><span class="line">        t.change(s1);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>由于StringBuffer是一个类，因此是按引用传递。<strong>但是</strong>这里的change方法不是对”hello “进行修改，而是使形参ss1的指向另一个字符串 “world”。而对形参ss1的改变对实参s1没有影响，实参s1仍然指向 “hello “。</p><p><u>引用就是指针吗？</u><br>不是，二者不能等同。虽然java引用在底层是通过指针实现的，但指针可以执行比较运算和整数的加减运算，而引用却不行。</p><h3 id="关键字-final"><a href="#关键字-final" class="headerlink" title="关键字 final"></a>关键字 final</h3><p>修饰变量时，用以定义常量；<br>修饰方法时，方法不能被重写（Override）；<br>修饰类时，类不能被继承。</p><h1 id="变量、数组、循环"><a href="#变量、数组、循环" class="headerlink" title="变量、数组、循环"></a>变量、数组、循环</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量的范围<br>1.变量声明在类下，叫做<strong>字段</strong>或者<strong>属性</strong>或者<strong>成员变量</strong><br>2.变量声明在一个方法上的，就叫做<strong>参数</strong>或者<strong>局部变量</strong></p><p>数据类型<br>八种基本类型(二进制位数)：<br> 整型 4种： byte（8位）、short（16位）、int（32位）、long（64位）<br> 浮点型 2种： float（32位）、double （64位）<br> 字符型 1种： char（16位）<br> 布尔型 1种：boolean（1位）</p><p> 现在问题来了</p><p><u>问：int和integer的区别？</u><br>答：1)int默认值为0。而integer默认值为null。由此可见,证int无法区分未赋值与赋值为0的情况,而integer却可以区分这两种情况。<br>2)int是是值传递。而integer是引用传递<br>3)int只能用来运算,而integer提供了很多有用的方法<br>4)当需要往容器(例如List)里存放整数时,无法直接存放int,因为List里面放的都是对象,所以,在这种情况下只能使用 Integer</p><p><u>问：char型变量中能不能存贮一个中文汉字?为什么?</u><br>答：char是16位的，占两个字节<br>汉字通常使用GBK或者UNICODE编码，也是使用两个字节，可以正常存放汉字。如果是utf-8编码，一个中文占三个字节，编译不会报错。但运行会报error“未结束的字符文字”</p><p><u>问：请解释这三条语句的输出</u><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  System.out.println((byte)127);//127</span><br><span class="line">System.out.println((byte)128);//-128</span><br><span class="line">System.out.println((byte)129);//-127</span><br></pre></td></tr></table></figure></p><p>答：byte的取值是{-128,127},如果把128强制转换成byte已结超出了byte范围，此时会溢出，相当于最小的负数-128.而129强转后就是-127</p><p><u>问：请解释这条语句的输出</u><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Math.min(Double.MIN_VALUE,0.0));//输出0.0</span><br></pre></td></tr></table></figure></p><p>答：对于Double来说MIN_VALUE并不是取值范围的最小数，而是正数范围的最小数，也就是最接近于0的正数。最接近于0的正数和0比起来，当然是0小。</p><p><u>问：在java里调用什么方法能把二进制数转化为十进制？</u><br>答：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.valueOf(&quot;11101&quot;,2));</span><br></pre></td></tr></table></figure></p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i1 = 10;</span><br><span class="line">byte b = (byte) i1;</span><br></pre></td></tr></table></figure><h4 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h4><p>把基本数据类型和对应的包装类之间转换。比如int和Integer。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = 100;  //自动装箱，编译器执行Integer.valueOf(100)</span><br><span class="line">int j = i;        //自动拆箱，编译器执行i.intValue()</span><br></pre></td></tr></table></figure></p><h4 id="与equals"><a href="#与equals" class="headerlink" title="==与equals()"></a>==与equals()</h4><p>==比较的是两个对象的引用是否相同，或者是比较原始数据类型是否相等；<br>equals()比较的是两个对象的内容是否相同。</p><h3 id="关于变量的题目"><a href="#关于变量的题目" class="headerlink" title="关于变量的题目"></a>关于变量的题目</h3><p><u> 题目一：解释为何行3编译错误，而行4编译正确</u><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        byte b1 = 3;</span><br><span class="line">        byte b2 = 4;</span><br><span class="line">        byte b3 = b1 + b2;                //编译错误</span><br><span class="line">        byte b4 = 3 + 4;                //编译正确</span><br><span class="line">//（1）变量相加，首先首先进行类型提升，之后再进行计算，计算后将结果赋值；</span><br><span class="line">//（2）常量相加，首先进行计算，之后判断是否在接受类型的范围，在则赋值。</span><br></pre></td></tr></table></figure></p><p><u><br>题目二：判断下列代码是否有误，并指出错误</u><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        short s = 1;</span><br><span class="line">        s = s + 1;                //错误，s在参加运算时会自动提示类型为int。int类型值无法直接赋值于short类型</span><br><span class="line">        </span><br><span class="line">        short z = 1;</span><br><span class="line">        z += 1;                //正确,扩展赋值运算符包含强制类型转换。等价于 z = (short)(z + 1);</span><br><span class="line">//还有，-128~127的Integer值可以从缓存中取得。其他情况要重新创建</span><br></pre></td></tr></table></figure></p><p><u>题目三，int i = 1;i+=++i;的运算结果？</u><br>i+=++i,其中先算++i,得到2<br>由于++i并未进行赋值，所以i还是1<br>1+=2结果为3</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>一维数组的3种创建方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[] arr1 = &#123;1,2,3,4&#125;;             //正确</span><br><span class="line">int[] arr2 = new int[4];            //正确</span><br><span class="line">int[] arr3 = new int[]&#123;1,2,3,4&#125;;    //正确</span><br><span class="line">int[] arr4 = new int[4]&#123;1,2,3,4&#125;;  //错误，编译不通过</span><br></pre></td></tr></table></figure></p><p>二维数组的3种声明方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int arr1[][];</span><br><span class="line">int [][]arr2;</span><br><span class="line">int []arr3[];</span><br></pre></td></tr></table></figure></p><p>与C/C++不同的是，java的二维数组允许第二维的长度可以不同。</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p><u>写出下面程序运行结果</u><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">   static boolean p(char c) &#123;</span><br><span class="line">       System.out.print(c);</span><br><span class="line">       return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       int i=0;</span><br><span class="line">        for (p(&apos;a&apos;); p(&apos;b&apos;)&amp;&amp;i&lt;2; p(&apos;c&apos;)) &#123;//for(表达式1;表达式2;表达式3)&#123;循环体]</span><br><span class="line">            p(&apos;d&apos;);</span><br><span class="line">            i++; &#125; &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>因为，1.初始化只会执行一次2.先执行循环体后执行for循环的表达式3<br>所以答案是：abdcbdcb</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">switch(day)&#123;</span><br><span class="line">           case 1:</span><br><span class="line">               System.out.println(&quot;星期一&quot;);</span><br><span class="line">               break;</span><br><span class="line">           case 2:</span><br><span class="line">               System.out.println(&quot;星期二&quot;);</span><br><span class="line">               break;</span><br><span class="line">           case 3:</span><br><span class="line">               System.out.println(&quot;星期三&quot;);</span><br><span class="line">               break;</span><br><span class="line">           case 4:</span><br><span class="line">               System.out.println(&quot;星期四&quot;);</span><br><span class="line">               break;</span><br><span class="line">           case 5:</span><br><span class="line">               System.out.println(&quot;星期五&quot;);</span><br><span class="line">               break;</span><br><span class="line">           case 6:</span><br><span class="line">               System.out.println(&quot;星期六&quot;);</span><br><span class="line">               break;</span><br><span class="line">           case 7:</span><br><span class="line">               System.out.println(&quot;星期天&quot;);</span><br><span class="line">               break;</span><br><span class="line">           default:</span><br><span class="line">               System.out.println(&quot;输入有误&quot;);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><strong>使用switch特别注意，必须在case语句后加break </strong>   </p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public enum Season &#123;//是枚举enum不是类class</span><br><span class="line">            SPRING, SUMMER, AUTUMN, WINTER;//直接这样写</span><br><span class="line"></span><br><span class="line">            public static void main(String[] args) &#123;</span><br><span class="line">                Season season = Season.SPRING;</span><br><span class="line">                switch (season) &#123;</span><br><span class="line">                    case SPRING:</span><br><span class="line">                        System.out.println(&quot;春天&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    case SUMMER:</span><br><span class="line">                        System.out.println(&quot;夏天&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    case AUTUMN:</span><br><span class="line">                        System.out.println(&quot;秋天&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    case WINTER:</span><br><span class="line">                        System.out.println(&quot;冬天&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                &#125;&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="如何跳出多重循环？"><a href="#如何跳出多重循环？" class="headerlink" title="如何跳出多重循环？"></a>如何跳出多重循环？</h4><p>在外部循环的前一行，加上自定义标签，比如 out:<br>在break的时候使用该标签。break out;</p><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h2><p>可以被看作外部类的一个成员（与类的属性和方法类似）<br>1可以自由的引用外部类的属性和方法。2外部类被实例化之后，内部类才能被实例化。3不能有静态成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Hero &#123;//英雄类</span><br><span class="line">    private String name; </span><br><span class="line">    float hp; </span><br><span class="line">    // 非静态内部类，只有一个外部类对象存在的时候，才有意义</span><br><span class="line">    // 比如战斗成绩只有在一个英雄对象存在的时候才有意义</span><br><span class="line">    </span><br><span class="line">    class BattleScore &#123;//战斗成绩类</span><br><span class="line">        int kill;</span><br><span class="line"></span><br><span class="line">        public void legendary() &#123;</span><br><span class="line">            if (kill &gt;= 8)</span><br><span class="line">                System.out.println(name + &quot;超神！&quot;);</span><br><span class="line">            else</span><br><span class="line">                System.out.println(name + &quot;尚未超神！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero garen = new Hero();</span><br><span class="line">        garen.name = &quot;盖伦&quot;;</span><br><span class="line">        </span><br><span class="line">        // BattleScore对象只有在一个英雄对象存在的时候才有意义</span><br><span class="line">        BattleScore score = garen.new BattleScore();// 所以其实例化必须建立在一个外部类对象的基础之上</span><br><span class="line">                                                    </span><br><span class="line">        score.kill = 9;</span><br><span class="line">        score.legendary();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类。"><a href="#静态内部类。" class="headerlink" title="静态内部类。"></a>静态内部类。</h2><p>1不能访问外部类普通成员，只能访问外部内中静态成员和静态方法。<br>2可以不依赖于外部类实例化而实例化。<br>3不可以与外部类同名。</p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>是指定义在一个代码块内的类，不可以被修饰符修饰。</p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>是一种没有类名的内部类，不使用关键字class、extends、implement，没有构造方法，必须继承类或其他接口。一般用于gui编程中事件处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Hero&#123;</span><br><span class="line"></span><br><span class="line">    public abstract void attack();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Hero h = new Hero()&#123;</span><br><span class="line">            //当场实现attack方法</span><br><span class="line">            public void attack() &#123;</span><br><span class="line">                System.out.println(&quot;新的进攻手段&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        h.attack();</span><br><span class="line">        //通过打印h，可以看到h这个对象属于Hero$1这么一个系统自动分配的类名</span><br><span class="line">        System.out.println(h);</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>%s 表示字符串<br>%d 表示数字<br>%n 表示换行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String name =&quot;盖伦&quot;;</span><br><span class="line">int kill = 8;</span><br><span class="line">String title=&quot;超神&quot;;</span><br><span class="line"> </span><br><span class="line">String sentenceFormat =&quot;%s 在进行了连续 %d 次击杀后，获得了 %s 的称号%n&quot;;</span><br><span class="line">//使用printf格式化输出</span><br><span class="line">System.out.printf(sentenceFormat,name,kill,title);//第一个是原字符串</span><br></pre></td></tr></table></figure></p><h2 id="StringBuffer追加-删除-插入-反转"><a href="#StringBuffer追加-删除-插入-反转" class="headerlink" title="StringBuffer追加 删除 插入 反转"></a>StringBuffer追加 删除 插入 反转</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;let there &quot;;</span><br><span class="line">StringBuffer sb = new StringBuffer(str1); //根据str1创建一个StringBuffer对象</span><br><span class="line">sb.append(&quot;be light&quot;); //在最后追加</span><br><span class="line">sb.delete(4, 10);//删除4-10之间的字符</span><br><span class="line">sb.insert(4, &quot;there &quot;);//在4这个位置插入 there</span><br><span class="line">sb.reverse(); //反转</span><br></pre></td></tr></table></figure><h2 id="字符串的转化"><a href="#字符串的转化" class="headerlink" title="字符串的转化"></a>字符串的转化</h2><h3 id="数字与字符串"><a href="#数字与字符串" class="headerlink" title="数字与字符串"></a>数字与字符串</h3><ul><li>数字转字符串<br>方法1： 使用String类的静态方法valueOf<br>String str = String.valueOf(i);<br>方法2： 先把基本类型装箱为对象，然后调用对象的toString<br>Integer it = i;<br>String str2 = it.toString();</li></ul><ul><li>字符串转数字<br>String str = “999”;<br>int i= Integer.parseInt(str);</li></ul><h3 id="字符串与字符串数组"><a href="#字符串与字符串数组" class="headerlink" title="字符串与字符串数组"></a>字符串与字符串数组</h3><ul><li>字符数组 转 字符串<br>char[] data={‘a’,’b’,’c’};<br>String s=new String(data);</li></ul><p>字符数组转换成字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char[]   data=&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125;;   </span><br><span class="line">String  s=new   String(data);</span><br></pre></td></tr></table></figure></p><p>s1.charAt(0)=c1;是不行的<br>s1.charAt(0);是可以的</p><h2 id="字符串是否相等的提问"><a href="#字符串是否相等的提问" class="headerlink" title="字符串是否相等的提问"></a>字符串是否相等的提问</h2><p>问：1和2处分别输出什么?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> String str1 = &quot;the light&quot;;</span><br><span class="line"> String str2 = new String(str1);</span><br><span class="line"> System.out.println( str1  ==  str2);//1</span><br><span class="line">String str4 = new String(&quot;the light&quot;);//2</span><br><span class="line"></span><br><span class="line"> String str3 = &quot;the light&quot;;</span><br><span class="line"> String str4 = &quot;the light&quot;;</span><br><span class="line"> System.out.println( str4  ==  str3);//3</span><br></pre></td></tr></table></figure></p><p>答：1输出false。因为new String会为str2开辟一个新的区域.<br>2输出true。因为str3创建了一个新的字符串”the light”，在str4编译器发现已经存在现成的”the light”，那么就直接拿来使用，而没有进行重复创建</p><h1 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h1><h2 id="格式化时间"><a href="#格式化时间" class="headerlink" title="格式化时间"></a>格式化时间</h2><p>时间（注意月和小时是大写的喔）</p><p>y 代表年<br>M 代表月<br>d 代表日<br>H 代表24进制的小时<br>h 代表12进制的小时<br>m 代表分钟<br>s 代表秒<br>S 代表毫秒<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Date d = new Date();</span><br><span class="line">System.out.println(d);//输出当前时间</span><br><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日,HH时mm分ss秒&quot;);//设置样式</span><br><span class="line">String s = sdf.format(d);//把d这个时间实例格式化，并且赋值给字符串s</span><br><span class="line">System.out.println(s);//输出的字符串s就是格式化好的时间啦</span><br></pre></td></tr></table></figure></p><h2 id="日历（可以做“查看明年的今天是几号”之类的事）"><a href="#日历（可以做“查看明年的今天是几号”之类的事）" class="headerlink" title="日历（可以做“查看明年的今天是几号”之类的事）"></a>日历（可以做“查看明年的今天是几号”之类的事）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();//Calendar用单例模式创造实例</span><br><span class="line">Date now = c.getTime();</span><br><span class="line"></span><br><span class="line">c.setTime(now);</span><br><span class="line">//先翻到下下个月</span><br><span class="line">c.add(Calendar.MONTH,2);</span><br><span class="line">//设置到月初</span><br><span class="line">c.set(Calendar.DATE,1);</span><br><span class="line">//再往回翻3天</span><br><span class="line">c.add(Calendar.DATE,-3);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;下个月的倒数第3天是哪天&quot;+s);</span><br></pre></td></tr></table></figure><h1 id="一些基础但不重要的知识"><a href="#一些基础但不重要的知识" class="headerlink" title="一些基础但不重要的知识"></a>一些基础但不重要的知识</h1><ul><li>变量名起名规则<ol><li>字母 数字 $ _ 组成</li><li>变量第一个字符，不能使用数字。</li><li>不可以使用关键字。<br>为什么不重要？<br>起名的时候选择有意义描述性的词比如“toString””getFlow”，不要用关键字。起名规则无需死记硬背。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>javaEE</title>
      <link href="/2018/10/04/javaweb/"/>
      <url>/2018/10/04/javaweb/</url>
      
        <content type="html"><![CDATA[<h1 id="javabean"><a href="#javabean" class="headerlink" title="javabean"></a>javabean</h1><p>三要素<br>1.一个无参的构造函数<br>2.属性私有化。<br>3.get、set的方法。私有化的属性必须通过public类型的方法给其它程序，并且方法的命名也必须遵守一定的命名规范。</p><h1 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h1><h2 id="写一个servlet"><a href="#写一个servlet" class="headerlink" title="写一个servlet"></a>写一个servlet</h2><p>第一步：html表单提交请求<br><code>&lt;form action=&quot;login&quot; method=&quot;post&quot;&gt;</code></p><p>第二步：servlet类中的请求处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class LoginServlet extends HttpServlet &#123;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response)</span><br></pre></td></tr></table></figure></p><p>第三步：配置web.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet-name&gt;L1&lt;/servlet-name&gt;//类的缩写</span><br><span class="line">    &lt;servlet-class&gt;Myservlet.LoginServlet&lt;/servlet-class&gt;//类的名称</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;L1&lt;/servlet-name&gt;//类的缩写，和上面一致就行</span><br><span class="line">    &lt;url-pattern&gt;/login&lt;/url-pattern&gt;//映射为的url地址，注意有“/”。对应&lt;form action=&quot;login&quot;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></p><h2 id="处理请求的三种方法"><a href="#处理请求的三种方法" class="headerlink" title="处理请求的三种方法"></a>处理请求的三种方法</h2><p>1、dopost、doget、service<br>doget：是默认方法，比如超链访问、地址栏直接输入某个地址。<br>特点：1.不安全，提交数据会在浏览器地址栏显示出来<br>2.不可以上传文件<br>3.有大小的限制</p><p>dopost：一般用于注册、修改请求<br>特点：1.安全<br>2.可以上传文件<br>3.没有限制</p><h2 id="request和reponse常用方法"><a href="#request和reponse常用方法" class="headerlink" title="request和reponse常用方法"></a>request和reponse常用方法</h2><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p><strong>request.getParameter(): 是常见的方法，用于获取单值的参数</strong><br>request.getParameterValues(): 用于获取具有多值得参数，比如注册的时候提交的爱好，可以使多选的。<br>request.getParameterMap(): 用于遍历所有的参数，并返回Map类型。</p><p>request.getRequestURL(): 浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)” +<br>request.getRequestURI(): 浏览器发出请求的资源名部分，去掉了协议和主机名” +<br>request.getQueryString(): 请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到<br>request.getRemoteAddr(): 浏览器所处于的客户机的IP地址<br>request.getRemoteHost(): 浏览器所处于的客户机的主机名<br>request.getRemotePort(): 浏览器所处于的客户机使用的网络端口<br>request.getLocalAddr(): 服务器的IP地址<br>request.getLocalName(): 服务器的主机名<br>request.getMethod(): 得到客户机请求方式一般是GET或者POST</p><p>request.getHeader() 获取浏览器传递过来的头信息。比如getHeader(“user-agent”) 可以获取浏览器的基本资料，这样就能判断是firefox、IE、chrome、或者是safari浏览器<br>request.getHeaderNames() 获取浏览器所有的头信息名称，根据头信息名称就能遍历出所有的头信息</p><h3 id="reponse-待完善"><a href="#reponse-待完善" class="headerlink" title="reponse(待完善)"></a>reponse(待完善)</h3><p>用于提供给浏览器的响应信息</p><h2 id="服务端跳转和客户端跳转"><a href="#服务端跳转和客户端跳转" class="headerlink" title="服务端跳转和客户端跳转"></a>服务端跳转和客户端跳转</h2><p>服务端跳转<br><code>request.getRequestDispatcher(&quot;success.html&quot;).forward(request, response);</code></p><p>客户端跳转<br><code>response.sendRedirect(&quot;fail.html&quot;);</code></p><p>区别在于<strong>客户端跳转时</strong>候浏览器地址发生了变化</p><h2 id="中文问题"><a href="#中文问题" class="headerlink" title="中文问题"></a>中文问题</h2><h3 id="获取中文参数，只需三步"><a href="#获取中文参数，只需三步" class="headerlink" title="获取中文参数，只需三步"></a>获取中文参数，只需三步</h3><ol><li>login.html中加上</li></ol><p><code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</code></p><p>这句话的目的是告诉浏览器，等下发消息给服务器的时候，使用UTF-8编码</p><ol start="2"><li><p>login.html<br>form的method修改为post</p></li><li><p>在servlet进行解码和编码<br>把下面这句代码放在request.getParameter()之前<br><code>request.setCharacterEncoding(&quot;UTF-8&quot;);</code><br>这句话的目的UTF-8解码，然后用UTF-8编码</p></li></ol><h3 id="返回中文的响应"><a href="#返回中文的响应" class="headerlink" title="返回中文的响应"></a>返回中文的响应</h3><p>在Servlet中，加上<br><code>response.setContentType(&quot;text/html; charset=UTF-8&quot;);</code></p><h2 id="servlet的一些概念"><a href="#servlet的一些概念" class="headerlink" title="servlet的一些概念"></a>servlet的一些概念</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>servlet生命周期有5步：实例化，初始化，提供服务，销毁，被回收<br>初始化：（ init(ServletConfig) 实例方法，只会执行一次）<br>LoginSerlvet构造方法 只会执行一次，所以Serlvet是单实例的</p><h2 id="servlet和jsp"><a href="#servlet和jsp" class="headerlink" title="servlet和jsp"></a>servlet和jsp</h2><p>jsp就是在html里面写java代码，servlet就是在java里面写html代码</p><p>jsp更注重前端显示，servlet更注重模型和业务逻辑</p><p>jsp经过容器解释之后就是一个servlet类.<br>我们说HelloServlet是一个Servlet，不是因为它的类名里有一个”Servlet”，而是因为它继承了 HttpServlet<br>打开转译hello.jsp 后得到的hello_jsp.java，可以发现它继承了类HttpJspBase，而HttpJspBase 继承了HttpServlet<br>所以我们说hello_.jsp.java 是一个Servlet</p><h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><h2 id="页面元素"><a href="#页面元素" class="headerlink" title="页面元素"></a>页面元素</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1. 静态内容</span><br><span class="line">就是html,css,javascript等内容</span><br><span class="line">2. 指令</span><br><span class="line">以&lt;%@开始 %&gt; 结尾，比如&lt;%@page import=&quot;java.util.*&quot;%&gt;</span><br><span class="line">3. 表达式 &lt;%=%&gt;</span><br><span class="line">4. Scriptlet</span><br><span class="line">在&lt;%%&gt; 之间，可以写任何java 代码</span><br><span class="line">5. 声明</span><br><span class="line">在&lt;%!%&gt; 之间可以声明字段或者方法。但是不建议这么做。</span><br><span class="line">6. 动作</span><br><span class="line">&lt;jsp:include page=&quot;Filename&quot; &gt; 在jsp页面中包含另一个页面。在包含的章节有详细的讲解</span><br><span class="line">7. 注释 &lt;%-- -- %&gt;</span><br><span class="line">不同于 html的注释 &lt;!-- --&gt; 通过jsp的注释，浏览器也看不到相应的代码，相当于在servlet中注释掉了</span><br><span class="line"></span><br><span class="line">8. 表达式</span><br><span class="line">用于输出一段html，比如&lt;%=&quot;hello jsp&quot;%&gt;相当于&lt;%out.println(&quot;hello jsp&quot;);%&gt;</span><br><span class="line">再比如</span><br><span class="line">&lt;%for (String word : words) &#123;%&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;td&gt;&lt;%=word%&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;%&#125;%&gt;</span><br></pre></td></tr></table></figure><h2 id="九大内置对象"><a href="#九大内置对象" class="headerlink" title="九大内置对象"></a>九大内置对象</h2><p>request,response,out</p><p>pageContext, session,application作用域：页面、用户、全局</p><p>page,config,exception</p><p>使用javabean</p><h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><p>设置<br><code>session.getAttribute(&quot;name&quot;);</code><br>取得<br><code>String name = (String)session.getAttribute(&quot;name&quot;);</code></p><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//创健</span><br><span class="line">Cookie u= new Cookie(&quot;username&quot;,username);键，值对的关系存储`</span><br><span class="line">//设置生存时间</span><br><span class="line">u.setMaxAge(864000);`</span><br><span class="line">//保存 </span><br><span class="line">response.addCookie(u);`</span><br><span class="line"></span><br><span class="line">//把所有cookie取出来装入数组 Cookie[] cookies = request.getCookies();</span><br><span class="line">if(c.getName().equals(&quot;username&quot;)||c.getName().equals(&quot;password&quot;))</span><br><span class="line">  &#123;c.setMaxAge(0); //设置Cookie失效</span><br><span class="line">  response.addCookie(c); //重新保存。</span><br><span class="line"></span><br><span class="line">//取键 </span><br><span class="line">if(c.getName().equals(&quot;username&quot;))</span><br><span class="line"> </span><br><span class="line">//取值</span><br><span class="line">username = URLDecoder.decode(c.getValue(),&quot;utf-8&quot;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hibernate简单入门</title>
      <link href="/2018/09/27/Hibernate/"/>
      <url>/2018/09/27/Hibernate/</url>
      
        <content type="html"><![CDATA[<h1 id="Hibernate简单入门"><a href="#Hibernate简单入门" class="headerlink" title="Hibernate简单入门"></a>Hibernate简单入门</h1><p>用这个框架，只需要三步。配置Product.hbm.xml文件和hibernate.cfg.xml文件、编写测试类</p><h2 id="Product-hbm-xml文件"><a href="#Product-hbm-xml文件" class="headerlink" title="Product.hbm.xml文件"></a>Product.hbm.xml文件</h2><p>作用是将javabean对应数据库中的表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">   &lt;!DOCTYPE hibernate-mapping PUBLIC</span><br><span class="line">           &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;</span><br><span class="line">           &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;</span><br><span class="line">    </span><br><span class="line">   &lt;hibernate-mapping package=&quot;com.how2java.pojo&quot;&gt;</span><br><span class="line">       &lt;class name=&quot;Product&quot; table=&quot;product_&quot;&gt;//表示类Product对应表product_</span><br><span class="line"></span><br><span class="line">           &lt;id name=&quot;id&quot; column=&quot;id&quot;&gt;//表示属性id,映射表里的字段id</span><br><span class="line">               &lt;generator class=&quot;native&quot;&gt;//意味着id的自增长方式采用数据库的本地方式</span><br><span class="line">               &lt;/generator&gt;</span><br><span class="line">           &lt;/id&gt;</span><br><span class="line">           &lt;property name=&quot;name&quot; /&gt;//这里没有通过column=&quot;name&quot; 显式的指定字段），因为属性和字段同名</span><br><span class="line">           &lt;property name=&quot;price&quot; /&gt;</span><br><span class="line">       &lt;/class&gt;</span><br><span class="line">        </span><br><span class="line">   &lt;/hibernate-mapping&gt;</span><br></pre></td></tr></table></figure></p><h2 id="hibernate-cfg-xml文件"><a href="#hibernate-cfg-xml文件" class="headerlink" title="hibernate.cfg.xml文件"></a>hibernate.cfg.xml文件</h2><p>访问数据库配置。注意，这个文件要放在<strong>src目录</strong>下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;</span><br><span class="line">&lt;!DOCTYPE hibernate-configuration PUBLIC</span><br><span class="line">       &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;</span><br><span class="line">&quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;</span><br><span class="line"> </span><br><span class="line">&lt;hibernate-configuration&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;session-factory&gt;</span><br><span class="line">        &lt;!-- Database connection settings --&gt;</span><br><span class="line">        &lt;property name=&quot;connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;connection.url&quot;&gt;jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8&lt;/property&gt;//这表示使用MYSQL方言</span><br><span class="line">        &lt;property name=&quot;connection.username&quot;&gt;root&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;connection.password&quot;&gt;admin&lt;/property&gt;</span><br><span class="line">        &lt;!-- SQL dialect --&gt;</span><br><span class="line">        &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;current_session_context_class&quot;&gt;thread&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt;//这表示是否在控制台显示执行的sql语句</span><br><span class="line">        &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt;//这表示是否会自动更新数据库的表结构，有这句话Hibernate会自动去创建表结构</span><br><span class="line">        &lt;mapping resource=&quot;com/how2java/pojo/Product.hbm.xml&quot; /&gt;//识别Product这个实体类</span><br><span class="line">    &lt;/session-factory&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/hibernate-configuration&gt;</span><br></pre></td></tr></table></figure></p><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>hibernate的基本步骤是：</p><ol><li>获取SessionFactory </li><li>通过SessionFactory 获取一个Session</li><li>在Session基础上开启一个事务</li><li>通过调用Session的save方法把对象保存到数据库</li><li>提交事务</li><li>关闭Session</li><li>关闭SessionFactory<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SessionFactory sf = new Configuration().configure().buildSessionFactory();//1.获取SessionFactory</span><br><span class="line"></span><br><span class="line">Session s = sf.openSession();//2.通过SessionFactory 获取一个Session</span><br><span class="line">s.beginTransaction();//3.在Session基础上开启一个事务</span><br><span class="line"></span><br><span class="line">Product p = new Product();</span><br><span class="line">p.setName(&quot;iphone7&quot;);</span><br><span class="line">p.setPrice(7000);</span><br><span class="line">s.save(p);//4. 通过调用Session的save方法把对象保存到数据库</span><br><span class="line"></span><br><span class="line">s.getTransaction().commit();//5. 提交事务</span><br><span class="line">s.close();//6. 关闭Session</span><br><span class="line">sf.close();//7. 关闭SessionFactory</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS拾遗</title>
      <link href="/2018/09/18/css/"/>
      <url>/2018/09/18/css/</url>
      
        <content type="html"><![CDATA[<h1 id="css的三种写处"><a href="#css的三种写处" class="headerlink" title="css的三种写处"></a>css的三种写处</h1><h2 id="内联式"><a href="#内联式" class="headerlink" title="内联式"></a>内联式</h2><p><code>style=&quot;color:red;&quot;</code></p><h2 id="嵌入式"><a href="#嵌入式" class="headerlink" title="嵌入式"></a>嵌入式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="外部式"><a href="#外部式" class="headerlink" title="外部式"></a>外部式</h2><p>css外部式<br><code>&lt;link href=&quot;css/style.css&quot; rel=&quot;stylesheet&quot;&gt;</code></p><p>js外部式<br><code>&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt;</code></p><h2 id="优先级：内联式-gt-嵌入式-gt-外部式"><a href="#优先级：内联式-gt-嵌入式-gt-外部式" class="headerlink" title="优先级：内联式 &gt; 嵌入式 &gt; 外部式"></a>优先级：内联式 &gt; 嵌入式 &gt; 外部式</h2><p>其实总结来说，就是–就近原则（离被设置元素越近优先级别越高）。</p><h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p&#123; color:red;&#125;/*元素选择器*/</span><br><span class="line"></span><br><span class="line">#p1&#123;color:blue;&#125;/*id选择器*/</span><br><span class="line"></span><br><span class="line">.after&#123;color:green; &#125;/*类选择器*/</span><br><span class="line"></span><br><span class="line">*&#123;color:red;&#125;/*通用选择器*/</span><br><span class="line"></span><br><span class="line">a:hover&#123;color:red;&#125;/*伪类选择器*/</span><br><span class="line"></span><br><span class="line"> h1,span&#123;color:red;&#125;/*两个都*/</span><br></pre></td></tr></table></figure><p>选择官方参考手册<a href="http://www.w3school.com.cn/cssref/css_selectors.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/cssref/css_selectors.asp</a></p><p>!important 注意要写在分号的前面，比如<br><code>a:hover{color:red!important;}/</code></p><h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><p>这个慕课老师发了许多关于布局的课程，其中一些给人启发<br><a href="http://www.imooc.com/t/197450" target="_blank" rel="noopener">http://www.imooc.com/t/197450</a></p><h2 id="一、基本知识"><a href="#一、基本知识" class="headerlink" title="一、基本知识"></a>一、基本知识</h2><ul><li>块级元素<br>特点：<br>1.一个块级元素独占一行<br>2.元素的高度、宽度、行高以及顶和底边距都可设置。<br>常用的块状元素有：<br><code>&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;、&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt;</code></li></ul><ul><li>内联元素<br>特点：<br>1.和其他元素都在一行上。<br>2.元素的高度、宽度及顶部和底部边距<strong>不可</strong>设置；<br>常用的内联元素有：<br><code>&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt;</code></li></ul><p>inline-block 元素特点：<br>1、和其他元素都在一行上；<br>2、元素的高度、宽度、行高以及顶和底边距都<strong>可</strong>设置。</p><p>display:block  – 显示为块级元素<br>display:inline  – 显示为内联元素<br>display:inline-block – 显示为内联块元素，表现为同行显示并可修改宽高内外边距等属性</p><p>tips：常将<ul>元素加上display:inline-block样式，原本垂直的列表就可以水平显示了。</ul></p><h2 id="二、定位"><a href="#二、定位" class="headerlink" title="二、定位"></a>二、定位</h2><h3 id="float浮动定位"><a href="#float浮动定位" class="headerlink" title="float浮动定位"></a>float浮动定位</h3><p>float的设计初衷仅仅是-文字环绕效果<br>属性有left、right、none</p><h3 id="positioin"><a href="#positioin" class="headerlink" title="positioin"></a>positioin</h3><p>relative相对定位：相对于它的初始位置而言移动。不可层叠。<br>absolute绝对定位：相对于最近的已定位的父元素。可层叠。<br>fixed悬浮定位：本质和absolute一样，不过不随浏览器滚动条向上或向下移动。</p><h2 id="三、盒模型"><a href="#三、盒模型" class="headerlink" title="三、盒模型"></a>三、盒模型</h2><p>元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。</p><h2 id="四、布局模型"><a href="#四、布局模型" class="headerlink" title="四、布局模型"></a>四、布局模型</h2><p>  1、流动模型（Flow）</p><p>  2、浮动模型 (Float)<br>  float的设计初衷仅仅是-文字环绕效果<br>  3、层模型（Layer）</p><h1 id="静态网页常用代码"><a href="#静态网页常用代码" class="headerlink" title="静态网页常用代码"></a>静态网页常用代码</h1><h2 id="1-如何将网页整体居中？"><a href="#1-如何将网页整体居中？" class="headerlink" title="1.如何将网页整体居中？"></a>1.如何将网页整体居中？</h2><ul><li>方法一将整个网页放在一个大div容器下，容器设置margin和具体宽度。<br><code>&lt;div style=&quot;margin: 0 auto;width:1000px;&quot;&gt;</code><br>解释：上下边距为0，左右边距为自适应。</li><li>方法二1.定义大div的宽度 2.把容器position睡醒设置为relative 3.把left属性设置为50%<br><code>&lt;div style=&quot;width:1000px;position:relative;left:50%;&quot;&gt;</code></li></ul><h2 id="2-如何消除默认样式？"><a href="#2-如何消除默认样式？" class="headerlink" title="2.如何消除默认样式？"></a>2.如何消除默认样式？</h2><p><code>2.&lt;body style=&quot;margin:0;padding:0;&quot;&gt;</code></p><h2 id="3-如何隐藏滚动条？"><a href="#3-如何隐藏滚动条？" class="headerlink" title="3.如何隐藏滚动条？"></a>3.如何隐藏滚动条？</h2><ul><li><p>方法一html { overflow-y: scroll; }<br> 原理：强制显示ie的垂直滚动条，而忽略水平滚动条<br> 优点：完全解决了这个问题, 允许你保持完整的XHTML doctype.<br> 缺点：即使页面不需要垂直滚动条的时候也会出现垂直滚动条。</p></li><li><p>方法2:html { overflow-x: hidden; overflow-y: auto; }<br> 原理：隐藏横向滚动，垂直滚动根据内容自适应<br> 优点：在视觉上解决了这个问题.在不必要的时候, 未强制垂直滚动条出现.<br> 缺点：只是隐藏了水平滚动条，如果页面真正需要水平滚动条的时候，<br> 屏幕以外的内容会因为用户无法水平滚动，而看不到。</p></li></ul><h2 id="4-常用代码，搁这了，方便复制。"><a href="#4-常用代码，搁这了，方便复制。" class="headerlink" title="4.常用代码，搁这了，方便复制。"></a>4.常用代码，搁这了，方便复制。</h2><ul><li><p>清除一些默认样式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*&#123;margin:0;padding:0;&#125;</span><br><span class="line">body&#123;font-size:12px;&#125;</span><br><span class="line">img&#123;border:none;&#125;</span><br><span class="line">li&#123;list-style:none;&#125;</span><br><span class="line">input,select,textarea&#123;outline:none;&#125;</span><br><span class="line">textarea&#123;resize:none;&#125;</span><br><span class="line">a&#123;text-decoration:none;&#125;</span><br></pre></td></tr></table></figure></li><li><p>刚开始肯定就是刷刷几个div包起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>Bootstrap框架引用代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://how2j.cn/study/js/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;link href=&quot;http://how2j.cn/study/css/bootstrap/3.3.6/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;script src=&quot;http://how2j.cn/study/js/bootstrap/3.3.6/bootstrap.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《Data Structures and Other Objects Using Java》读书笔记</title>
      <link href="/2018/09/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/09/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>书是从学校图书馆借的，豆瓣评分寥寥，但我觉得海星鸭<br><a id="more"></a></p><p><em>段落根据我认为重要程度排名。</em></p><ul><li><p>p84<br>为什么要给自己给一个类写clone的方法？而不是直接调用父类的复制方法。<br>举个栗子，把数组a拷贝到副本b。如果直接去调用父类的复制方法。它会做什么呢？它会把b的引用都指向数组a，也就是说它并没有真正意义上的复制，而是偷懒把新引用指向原本的数组。<br>这样做有什么问题呢？问题在于对a数组修改都会影响到拷贝的副本b。显然这不是我们想要的。<br>所以我们得自己写一个clone类，循环遍历数组，挨个复制。<br>笔记：大家都知道集合有length（）方法，不需要知道怎么实现，只要能用就行了。但当我们自己去写一个集合类的时候，写这个方法就必须要考虑到方方面面了。这本书重点不在于告诉人java有多少个API，而是这些类、方法的实现原理。只有当我们去重写的时候才会深度去思考程序的设计的原理。<br>比如得知数组的长度，那么写属性size就行了，因为数组是固定长度的。<br>但是要得知集合的长度，需要写一个方法遍历得知，因为集合是自动增长的。</p></li><li><p>p8<br>final变量即这个变量是最终版本，不可变更，不能被继承。另外final变量的名称全部大写 。<br>比如一个常量-273。如果把它写成final变量,则是final MINMUM_CELSIUS=-273。<br>什么时候用常量？如果直接写c&lt;-273，那么阅读程序的人会在这里停住，直到想起-273是最小摄氏度为止。<br>当然了，有些众所周知的公式，其原始形式更易识别。</p></li><li><p>用static修饰的话，即使没有生成该对象的实例，也可使用该方法。毕竟如果只是想使用该方法，也没有必要生成一个实例。<br>比如java自带Math类，没有生成实例也可以直接用它生成random随机数的方法 。(Math.random() * 100)。这条语句是意思是生成一个一百以内的随机数。<br>如果没有用static修饰，绝对不能激活空引用的方法。绝不能访问null引用的实例变量。两种情况下都会引发nullpointerexception异常。</p></li><li><p>变量分引用变量和普通变量。<br>除了八种基本类型之一的任何变量，其余都是引向某一对象的引用变量。<br>引用变量：<br>有些为了省事的程序员用“油门对象t正在工作”，而不使用，“t引用的油门对象正在工作”<br>笔记：t不是这个油门对象的命名而是这个油门对象的引用。</p></li><li><p>p49<br>关于取名。名字最好是描述性的词<br>存取方法：比如“toString”；get+，比如”getFlow”<br>修改方法：动词<br>有返回值的静态方法：名词</p></li><li><p>如果方法需要返回多个信息，那么返回数组是一个有效的手段。</p></li><li><p>集合类不用定义容量，每当包要满时，方法就会实现，使得容量翻倍。<br>m*2+1。加1是为了使得即使容量为零，这一动作仍能起作用。</p></li><li><p>如果没有指定修饰符，则为默认访问，也叫包访问。可以访问同一个一个包的类。</p></li><li><p>递归不只是尾递归。</p></li><li><p>java的易移植性：程序变成字节码，这些字节码由jar运行时环境编译，jar可以免费获得，所以程序可以在不同的机器间进行移植。</p></li><li><p>每一个方法有参数，前置条件，返回值。前置条件比如参数c&gt;-273。</p></li><li><p>接口代码单词一般以-able为后缀。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《自卑与超越》读书摘录</title>
      <link href="/2018/09/08/%E3%80%8A%E8%87%AA%E5%8D%91%E4%B8%8E%E8%B6%85%E8%B6%8A%E3%80%8B/"/>
      <url>/2018/09/08/%E3%80%8A%E8%87%AA%E5%8D%91%E4%B8%8E%E8%B6%85%E8%B6%8A%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p>力荐这本书，让我受益匪浅。主要讲的是心智的成长与误区。<br><a id="more"></a></p><blockquote><p>发现她询问过的女孩中有百分之四十二想要当男孩，这意味着她们对自己的性别不满。当尚有一半人口处于失意和灰心之中时，又怎么可能解决爱情和婚姻问题呢？当女性始终面临着轻视，并认为自己只是男性的性对象，或是认为男性的见异思迁和不忠是天性使然时，这些问题能够轻易解决吗？</p></blockquote><blockquote><p>比如，有千千万万小说都是以新婚男女缔结良缘为结局，但那其实只是他们共同生活的开始。在这种情境下，小说常常将婚姻当作解决一切问题的灵丹妙药，就好像新婚夫妇从此一帆风顺，过上了幸福的生活。需要认识到的另一个重要事实是，爱情本身不能解决任何问题。爱情的形式各种各样，更有效的是靠努力、关心和合作解决婚姻的问题。</p></blockquote><blockquote><p>有人无法只爱一个人，他们必须得同时爱着两个人。只有这样才能让他们感到自由，他们可以从一个身边逃到另一个那里去，完全不用承担完整的爱情责任。两个都爱，等于谁都不爱。</p></blockquote><blockquote><p><strong>我们知道，决定一个人的并不是他所处的环境，而是他对自身处境的解读。</strong></p></blockquote><blockquote><p>爱情，以及它在婚姻中的圆满，是对异性伴侣最亲密的奉献，具体表现为生理上的吸引、相濡以沫的陪伴，以及生儿育女的共同愿望。</p></blockquote><blockquote><p>所有人都应该为自己的生活去挣钱，无视这一点的人会成为别人的负担。但如果孩子们只对挣钱感兴趣，便很容易脱离合作路线，一心只想着自己的利益。如果没有其他社会兴趣，只将“挣钱”当作唯一目标，为什么不能去抢、去坑蒙拐骗呢？就算不至于那么极端，就算拜金之下还残存有一丝社会兴趣，他们的行为对人类也不会有太多贡献</p></blockquote><blockquote><p>如果儿童从小就知道自己长大后想从事的职业，那他们的发展就简单多了。如果我们问他们长大想干什么，大部分儿童都会给出明确回答。<strong>然而，他们的答案通常并未经过认真思考。当他们说想当飞行员或汽车司机时，其实对自己所选择的职业并没有了解。我们的责任是挖掘出他们的回答下潜藏的动机，把握他们努力的方向，找出推动他们继续前进的因素，以及他们的目标和他们实现这个目标的方式。他们所选择的未来职业只是一种在他们看来体现了优越性的职业，但从这一选择上，我们可以发现其他的发展可能，去帮助他们实现目标。</strong></p></blockquote><blockquote><p>天才的训练都开始于幼年。我觉得，关于天才的问题将有助于了解整个课题。只有那些对人类的共同利益做出过卓越贡献的个体才被称为天才。我还想不出有哪位没能对人类做出任何贡献的天才。</p></blockquote><blockquote><p>四五岁前的努力和训练对孩子成年后的主要活动范围有着决定性影响。做职业指导时，我总要询问每个人的幼年生活，以及他们早年对什么最感兴趣。他们对这一时期的记忆可以准确地揭示出他们最常进行的训练：他们会透露自己的理想，以及这些理想在自己心目中的地位。后文中，我会回过来讲最初记忆的重要性。</p></blockquote><blockquote><p><strong>《罪与罚》中就是如此，主人公拉斯科利尼科夫在床上躺了两个月，考虑是否去杀人。他靠对自己质问“我是拿破仑，还是一只虱子”来鞭策自己。犯罪分子靠这样的幻想自我欺骗，自我激励。事实上，所有犯罪分子都知道，他们过着对社会无益的生活，也知道什么才是有用的生活。然而出于怯懦，他们拒绝有用的生活，而怯懦则是因为他们缺乏成为有用之材的能力。</strong>解决生命中的问题需要进行合作，他们对合作却一窍不通。之后，在想要逃脱自己的罪责时，我们会看见他们为自己辩护，想要博取宽容，“他有病”或是“他没工作”等等都被拿来当作借口。</p></blockquote><blockquote><p>碰儿童时必须多加小心。父母和孩子间温暖的拥抱和亲吻没有问题，只要没有不恰当地激起孩子的生理反应。成年人回忆童年时，经常有人跟我诉说在父母的书架上发现黄色读物或是看了色情电影之后的感受。最好不要让儿童接触到这些图书和影片。如果不在性欲上给孩子以刺激，可以避免很多麻烦。</p></blockquote><blockquote><p><strong>有时候，教师会对懒惰的学生说：“如果努力一点，你就能成为班上最聪明的学生。”如果不费吹灰之力就能获得这样的评价，他们为什么还要冒险去努力呢？也许一旦他们不再懒惰，就保不住这种深藏不露的聪明孩子的名声了。所以应该根据实际成绩来裁判，而不是他们本应能达到的目标。懒孩子的另一个优势是，只要他们稍稍使一点点力气，就能得到表扬。所有人都希望他们至少是已经开始努力了，热切地鼓励他们进一步提高，但其实同样的努力在勤奋的孩子身上根本就不值一提。就这样，懒孩子生活在他人的期待里。他们是被宠坏的孩子，从婴儿时期就开始习惯于期待不劳而获</strong></p></blockquote><blockquote><p>还有一些想要成为关注焦点的孩子，在周围环境不顺意时，就通过调皮捣蛋来获取关注。他们要么扰乱整个课堂，要么带领其他孩子逃学，要么不时惹是生非。责备和惩罚对他们毫无效果，只会让他们更加得意。他们宁愿被责罚也不愿被忽视，破坏行为所带来的不快惩罚对他们来说只是为了赢回关注所付出的合理代价。许多孩子只将惩罚视为个人挑战。他们把它当成竞争或比赛，看谁能坚持得更久。而赢家总是他们，因为主动权掌握在他们自己手中。所以有些与自己父母或老师作对的孩子，在接受惩罚时，不仅不会哭，还会笑。</p></blockquote><blockquote><p><strong>智力发展中最大的要素是兴趣，我们之前说过，能够阻碍兴趣发展的是灰心和恐惧，而不是缺乏遗传。毫无疑问，大脑的结构多少得自遗传，但它只是心智的工具，而非根源，</strong>而且如果大脑的损伤还没严重到我们现今所掌握的知识无法克服的程度，就仍然可以接受补偿性训练。在每种出类拔萃的能力背后，我们所发现的都是持久的兴趣和训练，而不是特异的遗传性状。</p></blockquote><blockquote><p><strong>“善”与“恶”，以及其他关于性格的表达，其意义都只存在于社会语境中。它们是在社会环境下，和其他人类共同培养训练出来的产物，它们蕴含着对一个人的行为是“有利他人”还是“损害他人”的判断。</strong>儿童出生前并没有能产生这一感知的社会环境</p></blockquote><blockquote><p>儿童和他们的父母也不应被告知智商分数。他们不了解测验的目的，也许会以为它代表着最终判决。教育最大的问题不在于儿童的极限，而在于他们的自我设限。如果孩子们知道他们的IQ分数低，也许就会丧失希望，认为自己与成功无缘。我们在教育中应该做的是尽力增强他们的自信和学习兴趣，破除生活中他们给自己的能力所加上的重重限制</p></blockquote><blockquote><p>现在有些学校已经采用视听结合的教学方法来上课，比如在传统课程中结合使用模型和图画。这一趋势值得鼓励并进一步发展。<strong>任何学科的最佳教学方式都是让它与现实生活紧密相关</strong>，让孩子能够看到教导的目的，并了解到所学内容的实用价值。有一个问题常常被提及，教孩子吸收知识和教会他们自我思考孰高孰低？在我看来，这两种方法不该割裂，而应该结合在一起。例如，结合造房子教数学就很生动有益，可以让他们算出需要多少木材，可以住多少人等等。</p></blockquote><blockquote><p>懒惰是野心与缺乏勇气并存的标志：野心如此之大，以至于人们看不到任何实现它的希望</p></blockquote><blockquote><p>在这类竞争中，女孩天生更有优势：在十六岁以前，无论身体还是心灵，她都比同龄男孩成长得快。结果可能就是她的哥哥放弃竞争，变得懒惰消极。这样的事情屡见不鲜。男孩有时会通过一些不那么光明磊落的手段来追求优势，比如吹牛和撒谎。在这种情形下，我们几乎可以立刻肯定女孩已经获得了胜利</p></blockquote><blockquote><p>这些性格特征并不只是见于人们清醒的时候。它们的痕迹体现于一切个性表达中，在睡梦中就更明显了。举例来说，长子女常常会做有关跌落的梦。他们本就处于顶端，但不确定自己是否能够一直保持这样的优势。而次子女则完全不同，他们常常勾勒出自己正在比赛的场面，或者是跟在火车后面奔跑，或者是骑着自行车比赛。有时候这些紧张匆忙的梦具有如此鲜明的特征，以至于我们可以轻易猜到做梦者是家中排行第二的孩子</p></blockquote><blockquote><p>有一种感觉一直吸引着教育者与心理学者的关注，那就是“害怕”。在个体心理学中，我们不再局限于寻找害怕产生的原因，而更注重探究它的目的。<strong>所有受宠爱的孩子都会害怕：透过害怕，他们能够得到关注</strong>于是他们将这种情绪建立在了自己的生活方式中。利用它，孩子可以成功地将母亲拖在身边。胆小的孩子往往都是娇生惯养的，而且希望能够继续被娇纵。</p></blockquote><blockquote><p><strong>有一个娇惯的孩子常常会在黑暗中大哭。一天夜里，当母亲听到哭声赶过来时，她问孩子：“你为什么会害怕？”孩子回答：“因为太黑了。”但母亲现在已经认识到了他这种行为的目的。“那我进来之后，”她说，“就没那么黑了吗？”黑暗本身并不重要，孩子对黑暗的恐惧仅仅意味着他不想与母亲分开。他的所有情感、所有力气和所有精神都专注于要创造一种情境，在这种情境下，他的母亲就不得不来照看他，再次回到他身边</strong>他努力用哭泣、喊叫、无法入睡或其他能让自己成为一个麻烦小家伙的方式，将母亲吸引到自己身边。</p></blockquote><blockquote><p><strong>家庭中无需权威</strong>，但却需要真正的合作。父亲与母亲必须通力合作，在有关孩子教育的问题上应当处处保持一致。无论父亲还是母亲，都不应表现出对某个孩子的偏爱，这一点极其重要。偏爱的危害怎么强调也不为过。孩子在童年时期出现的沮丧感，其根源几乎都在于感到有人比自己更受宠爱。</p></blockquote><blockquote><p>夫妻之间的性关系不容忽视。<strong>同样重要的是，当父母在向子女解释有关性的问题时，要小心不要一厢情愿地涉及太多，只要告诉孩子他们想要知道的，同时也是在他们当前的年龄阶段里能够理解的内容，就足够了。我认为当今有一种不恰当的倾向，那就是人们告诉孩子们的远远超过他们能够理解的。这可能诱发出一些孩子还没有准备好要应对的兴趣和感觉。性可能从此就变成了一件稀松平常、无足轻重的事情。这并不比过去人们在性问题上对孩子们欺骗或是讳莫如深来得高明。最好的方式，是找出孩子们真正好奇的是什么，实事求是地为他们做出解答，而不要将我们认为是常识的东西强加给他们。我们一定要保护他们的信任感，将我们正在与他们合作的感觉延续下去，至于我们真正应当关心的，是帮助孩子找到他们问题的解决之道。如果这样做了，我们就不会有太大的偏差</strong></p></blockquote><blockquote><p>一位父亲的职责可以概括为几句话。他必须证明，自己是妻子的好伴侣，是孩子的好伙伴，也是社会的好成员。他必须妥善处理生活中的三大问题——工作、友谊和爱情，还必须在照顾和保护家庭时与妻子平等合作。他不应忘记，女性在家庭生活中的地位是不容贬抑的。贬低母亲的地位并非他应该做的，相反，他应当与妻子相互配合。需要特别强调的一个重点在于，即便父亲是家庭的主要经济支柱，这也是夫妻共同的收获。他绝不可摆出一副施予者的模样，把家庭中所有其他人都变成接受者。对于和谐的婚姻来说，真相是，他去赚钱只不过是家庭劳动分工的结果。许多父亲利用他们的经济地位来作为统治家庭的理由。家庭中不应存在统治，任何可能导致不平等感的事情都应当被避免。</p></blockquote><blockquote><p>由于婚姻是平等的合作关系，所以没有哪一方应该凌驾于另一方之上。这一点应当值得更深入的探讨，而不是满足于我们已经习惯的状态。<strong>在家庭生活的所有行为中，最不需要的就是权威的存在，如果家庭中某一位成员特别重要，或是被认为其价值远远大于其他家庭成员，那就太不幸了</strong>。如果父亲脾气暴躁，试图掌控家庭中的其他成员，那么他的儿子对于男人的概念就会有所偏差。而他的女儿则会更加痛苦。在未来的生活中，她们都会将男人看成暴君。对她们来说，婚姻就意味着某种屈从和奴役。有时，当成年以后，她们还可能发展出对同性的兴趣，以此来寻求自我保护，对抗男性。</p></blockquote><blockquote><p>众所周知，继母不好当，失去了亲生母亲的孩子常常会与她们对抗。但问题并非不能解决的，我也曾经看到过许多非常成功的继母。只是太多时候继母都没有真正明白情况究竟是怎样的。一种可能的情况是，孩子在失去母亲后转而寻求父亲的关怀，并且得到了他的宠溺。而当父亲再婚时，他觉得父亲的宠爱被瓜分了，于是攻击继母。而继母如果觉得自己必须反击，那孩子就真的委屈了。她挑战了他们，于是他们奋起反抗。<strong>任何与孩子对抗的战斗终究都会是一场失败的战斗：他们永远不会被打败，也不会因为被战胜而与对手合作</strong>。在这些斗争中，最弱小的往往都是最后的胜利者。他们会拒绝提供被要求的东西，这样的方式注定难有收获。如果我们意识到合作与爱是永远无法靠力量强行获取的，想必这个世界上的紧张压力和无用功就会大大减少了</p></blockquote><blockquote><p>现在就让我们来看看她的梦吧。“好几个人和我一起坐在车里。”正如我们推测的，她擅长合作，喜欢和别人待在一起。“我们一直开到一片树林前面才停下来。每个人都下车跑进了树林里。他们中大部分人都比我个子大。”她再一次留意到了个头的差异。“但我努力及时赶到，和大家一起上了一部电梯。电梯向下开进了一个大约十英尺深的矿井里。我们都觉得，要是走出去一定会瓦斯中毒的。”现在她描绘出了一个危险情况。大多数人都会害怕某些确定的危险，要知道人类并非勇敢的生物。可是她的梦还有下文。“后来，我们走了出去，全都安然无恙。”在这里，你可以看到乐观的精神。如果一个人是乐于合作的，他们通常都会勇敢、乐观。“我们在那里待了一分钟，然后回到地面，赶快跑回了车里。”我深信这名女孩一直都是乐于合作的，但始终有个念头困扰着她——她总觉得自己如果能再高大一些就好了。在这里我们应该能看出一些紧张感，就好像能看到她踮起脚的模样一般。好在她喜欢与人交往，对分享成就很感兴趣，这能消解掉许多紧张感</p></blockquote><blockquote><p>她是个漂亮的姑娘，却总觉得人们都只不过是因为她好看的容貌才喜欢她，因此很害怕变丑或受伤。有魅力的人在我们的社会中更容易被人们记住，也更容易支配他人，这位姑娘就很明白这一点。可她还是想要成为一名男子，以男性的方式来掌控一切。所以心底里其实不太看重自己的美丽。 她最早的记忆是关于曾被一个男人吓到的故事，而且她也承认自己至今仍旧害怕会成为窃贼或袭击者的攻击目标。这看起来有些奇怪，一个有男性化倾向的女孩竟会害怕窃贼和袭击者。但其实并不奇怪，正是她的软弱决定了她的目标。她希望能在自己熟知并掌控的环境下生活，排除一切其他情况。窃贼和袭击者恰恰是不可控的，因此她更乐意将他们统统消灭。她想要轻轻松松地变成一个男性化的人，这样，就算不幸失败了，也总算是有个过得去的保护伞。我将这种对于女性角色的深刻不满称为“男性钦羡”（masculine protest），它的出现总是伴随着一种紧张感：“我是一个正在为身为女性的种种不利而努力抗争的人。</p></blockquote><blockquote><p>以下的考察能够直接帮助我们厘清梦的意义。我们在夜里做梦，但在清晨来临时却常常将梦境忘得一干二净。看似水过无痕，毫无踪迹可循。但真是这样吗？真的什么都没有留下吗？答案是，有的。梦所带给我们的感觉还保留着。没有任何画面，没有任何对于梦的理解，只有感觉久久萦绕。梦的目的必定就在于它们所激发出的感觉之中。而梦就是唤起感觉的工具与方式。之所以有梦，就是为了留下这些感觉</p></blockquote><blockquote><p>我们已经知道，人们认为梦能够为他们遇到的难题提供解决方案。由此不妨推论，人们做梦的目的就是为了寻找对于未来的指引和当前难题的解决方法。这与梦能够提供预示的观点相去甚远。我们还必须考虑到，做梦的人想要得到的是什么样的解决方案，又是从哪里找出它们的。很显然，比起对实际形势做出全盘考察并且审慎思考后找到的解决方法，出现在梦里的那些看起来会更糟糕一些。毋庸赘述，事实上，做梦的人只是希望能够在睡梦中轻松解决掉他们的麻烦。</p></blockquote><blockquote><p>“看来你的父亲是大错特错了，”我说，“他无时无刻不在想着将他的权威加诸你身上，这是非常不明智的。也许他有一些问题，需要看看医生。但你能怎么办呢？你不能期望去改变他。比方说，下雨了，你能做什么呢？你可以撑把伞，或是搭乘出租车，无论如何，想要打败甚至制服雨都是不可能的。而现在，你就是在和雨战斗。你认为这能够展示你的力量，能占据上风。但实际上，你比其他任何人所受到的伤害都多。</p></blockquote><blockquote><p>小时候的他是个不在乎整洁的孩子，羞怯、怕黑、害怕孤独。当我们听到孩子不爱干净时，就知道，一定是有人跟在他们身后随时收拾。当我们听到孩子害怕黑暗和孤单时，就能推断，一定有人总是在关注着他们，会去安慰他们</p></blockquote><blockquote><p>“过了一会儿，我们觉得想要再多尝一点，于是就自己动手了。”这是个勇敢的姑娘。她希望独立。“就在这时我的腿软了，苹果酒被打翻在地，酒窖里湿了一大片。”在这里，我们看到了一个禁酒主义者诞生的苗头。 “我不知道这件事跟我不喜欢苹果酒和其他酒精饮料有没有关系。”再一次，一个小小的意外事件成为了一个完整生活态度的成因。如果我们就事论事地来看，这件事并没有重要到足以造成如此深远影响的程度。可是这位女孩却把它当作了不喜欢酒精饮料的充足理由。我们或许能够发现这位女孩是一个善于吸取经验教训的人。也许她非常独立，犯错时总会自我纠正。这种品质可能是她整个生活的一大特点。从整段描述来看，她在说的似乎是：“我会犯错，但只要我发现了错误，就能及时改正。”如果是这样，她就能具备很好的性格，积极主动，勇于进取，总是渴望自我完善并改善处境，自然也就能拥有好的、有益的生活</p></blockquote><blockquote><p>当一个孩子被“炫耀”，那么他的兴趣很可能就在于赢得社会大众的喜爱，而非对其做出贡献</p></blockquote><blockquote><p>如果医生被问到他的早期记忆，那么多半都会有一些关于死亡的片段。“躺在棺材里，那么安静，那么苍白”——这是有关某个画面的记忆。这个女孩可能是视觉型的，喜欢观察世界</p></blockquote><blockquote><p>而最具启发性的，一是儿童展开他们故事的方式，二是他们能够想起的最早的事件。第一个记忆体现了个人生命观的基本准则，这是第一次令他感到满意的对于个人态度的表达。这令我们得以一窥他们所选择的个人发展的起点究竟是什么。若要探究一个人的个性，我绝不会不询问他最早的记忆。</p></blockquote><blockquote><p>在所有的心灵表达中，最能揭示真相的是个体的记忆。记忆是人们随身携带的提示器，记录着有关他们自己的局限和各种事件的意义。世上没有“偶然的记忆”。个体接受到的印象数不胜数，人们只会从中挑选出自认为与个人问题有关的来纳入记忆，不管它们是多么的模糊不清。这些记忆代表着他们的人生故事，一个他们不断对自己重复以从中摄取温暖或舒适感的故事。这个故事可以帮助人们将注意力集中在他们的目标上，或是用过往经验中的意义来武装他们，让他们可以用一种更为可靠的、经得起考验的方式来迎接未来。从日常的行为中，我们可以清楚地看到，记忆的作用在于稳定情绪。如果一个人遭遇了挫折，并且为之沮丧，那么他就会回想起从前曾经遭遇过的挫折。而当他感到振奋、高兴，充满勇气时，他就会选择完全不同的记忆，他想起的是那些高兴的事情，这些记忆让他更为乐观。同样的道理，如果遇到了一个难题，他就会唤出那些能够帮助自己调试好恰当态度的记忆，以便应对当下的情形</p></blockquote><blockquote><p>我们能够看出，伴随着对于缺憾的切实补偿，有人排除了某些可能性，有人却针对自我的局限加以训练。哲学家们为什么必须一次又一次地避世而居才能够思考和写作？由此就可以理解了。<strong>假使一个人的优越目标里匹配了高度的社会兴趣，那么虽说任何目标都难免有错失，可这个目标的错误却也不会太大</strong>。</p></blockquote><blockquote><p>我们人类的劳动分工为各种不同的目标提供了生存空间。或许，正如我们所见的，每一种目标都多多少少有一定的偏差，我们总能从中找出些可以批评的地方。可是人们的合作所需要的正是取长补短。对某一个孩子来说，优越感可能在于他所擅长的数学知识，对另一个而言则在于艺术，而第三个孩子又以健壮的体格见长。消化不良的孩子可能会认为自己的问题主要出在营养方面。如果相信研究食物能够改善他们的处境，那么他们的兴趣就有可能转向这一方面，结果就是，他们或许会成为一名职</p></blockquote><blockquote><p><strong>当陷入爱情时许多人都会感到软弱，在一定程度上，他们是对的。如果我们在恋爱，就必定变得温柔，我们对另一个人的兴趣也会让自己更容易受到伤害</strong></p></blockquote><blockquote><p>时至今日，我们还是常常在针对表征来处理问题。无论在医学上还是教育上，个体心理学都完全反对这种做法。如果孩子的数学一塌糊涂，或是在学校的表现很糟糕，那么我们若是仅仅针对这些方面来试图有所提升，只能是徒劳无功。或许他们是想让老师难受，甚至希望闹到被开除好彻底逃离学校。<strong>如果我们只用单一的方法来阻止他们，那他们总能找到另一条对策来达到他们的目的</strong>。</p></blockquote><blockquote><p>举例来说，我们时常发现，成为医生的人往往在他们童年很早的时候就开始面对死亡的现实。死亡给他们带来的最大印象，是威胁人类不安全外在的一个侧面。或许是双亲或兄弟姐妹中有人死去了，于是在他们后来的学习发展中，便致力于为自己或他人找到对抗死亡并增加安全感的方法。也有人将成为教师作为他们明确的目标，但我们很清楚究竟有多少种不同的教师。如果一名教师的社会情感程度较低，那他的优越目标就有可能是通过当老师成为小范围内的大人物。或许，只有在比自己更弱小、更没经验的人面前他才会觉得安全。而拥有高度社会情感的教师则会以平等的态度对待学生，他们是真心希望能够为人类福祉做出贡献的。在这里，我们只需要提出，教师与教师之间的能力和兴趣差别有多么大，而从他们的言行中又能如何清楚地看到其各自的个人目标。当一个目标被清晰地勾勒出来，个体的潜力就会被修剪压缩到适合这个目标；至于整体的目标——我们可以将它称为原型——却会在任何情况下都努力突破这些限制，找到一个途径来表现其个人设定的生命意义和争取优越感的终极理想</p></blockquote><blockquote><p><strong>成年人的神经官能症也是这样。设想一个例子，就说饱受偏头痛之苦的人们吧。头痛对他们来说就是很有用的工具，只要需要，它们就可以在任何特别的时刻发作。借助于头痛，他们可以不必面对生活中的麻烦。当他们不得不和陌生人打交道或是做决定时，头痛招之即来。与此同时，头痛还可以帮助他们操控他们的同事、搭档或家人</strong>。我们怎么能指望他们会放弃这样一种有力的武器呢？他们将疼痛加诸己身，但从他们的角度来说，却是再明智不过的投资了——它会带来所有他们能够期望的回报。当然，我们可以给患者一个惊人的解释来吓走他的头痛，就像用电击或一场假手术来治好士兵的战争疲劳症（shell-shocked）一样。或许药物治疗也能令某些症状有所缓解，让病人难以继续使用这些特别选择出来的症状。但是，只要他们的目标没有改变，哪怕治好了一种症状，他们也会找到另外一种来取而代之。“治好”了头痛，接着就可能出现失眠，或是其他一些新的症状。只要目标依旧，他们就一定要继续为之努力</p></blockquote><blockquote><p>举例来说，我们时常发现，成为医生的人往往在他们童年很早的时候就开始面对死亡的现实。死亡给他们带来的最大印象，是威胁人类不安全外在的一个侧面。或许是双亲或兄弟姐妹中有人死去了，于是在他们后来的学习发展中，便致力于为自己或他人找到对抗死亡并增加安全感的方法。也有人将成为教师作为他们明确的目标，但我们很清楚究竟有多少种不同的教师。如果一名教师的社会情感程度较低，那他的优越目标就有可能是通过当老师成为小范围内的大人物。或许，只有在比自己更弱小、更没经验的人面前他才会觉得安全。而拥有高度社会情感的教师则会以平等的态度对待学生，他们是真心希望能够为人类福祉做出贡献的。在这里，我们只需要提出，教师与教师之间的能力和兴趣差别有多么大，而从他们的言行中又能如何清楚地看到其各自的个人目标。当一个目标被清晰地勾勒出来，个体的潜力就会被修剪压缩到适合这个目标；至于整体的目标——我们可以将它称为原型——却会在任何情况下都努力突破这些限制，找到一个途径来表现其个人设定的生命意义和争取优越感的终极理想</p></blockquote><blockquote><p>我的一名病人在家中排行老二，他深受无法摆脱的罪恶感的困扰。他的父亲和哥哥都极其重视诚实这种品质。然而，在他七岁那年，他告诉学校老师，自己独立完成了一份家庭作业，可事实上，这份作业是哥哥帮他做的。这个男孩将他的罪恶感隐藏了三年。最后，他去见老师，坦承了这个糟糕的谎言。可老师只是付之一笑。接下来，他又哭泣着找到父亲，作了第二次坦白。这次他更成功一些，父亲为儿子的诚实而感到骄傲，夸奖并安慰了他。但尽管父亲原谅了他，男孩还是非常沮丧。至此，我们很难回避以下的结论：这位男孩为了这样微不足道的过失而如此严厉地自责，其实是想要证明自己高度的诚实与严谨。家庭中高尚的道德氛围使他期望在诚实方面有卓越的表现。面对哥哥在学业和社会上的成功，他感到自卑，因此努力尝试另辟蹊径来争取优越感</p></blockquote><blockquote><p>人们的兴趣和注意力指向何方，这是一个问题。如果朝着自我之外的目标而努力，那么自然而然地，他们就会很好地训练自己，做好准备，以求达成目标。任何困难在他们眼中都不过是成功路上需要跨越的障碍而已。反过来，如果他们的兴趣点只在于强调自身的不足，或是虽然对抗这种不足，但只是为了使自己从中脱身，他们就很难取得真正的进步。一只笨拙的右手不会因为人心里想着要变得灵巧，盼望着少些笨拙，甚至避开那些会显示出其笨拙的场面，就变成了灵巧的右手。只有通过实打实的练习，笨拙的手才有可能灵巧起来，并且对于“将来能够做好”的渴望，要远远超过当下的笨拙所带来的挫败感。如果孩子们要调动他们的能量来克服困难，那么一定得有一个外在于自身的行动目标，这个目标建立在对于现实、他人乃至合作的兴趣之上。</p></blockquote><blockquote><p>一项针对梦境和联想的调查可能被证实是有用的：个性人格无论在梦境中还是现实生活中都不会改变，但在梦境中时来自社会的压力相对较小，也无需那么多的戒备与隐藏，个性得以更多的释放。然而要破解人们赋予自己以及个人生活的意义，最有力的帮手便是他们的记忆库了。<strong>每一份记忆，哪怕是被他们自己视为微不足道的琐事，都很重要。只要记得，就说明它们值得记忆，而之所以值得记忆，是因为这些都与他所设想的生活相关。它在对他们附耳低语，“这是你应该期待的”，或“这是你一定要避免的”，甚至断言“这就是人生”</strong>。在此我们必须重申，经验本身并非如它们在记忆中所占的地位那么重要，重要的只是它们的用途——被用来印证生命的意义。每一份记忆都经过了我们的粉饰</p></blockquote><blockquote><p>五岁前，儿童已经形成了一套完整而牢固的行为模式，能够开始用他们自己的方式来应对问题和任务，我们将这称为他们的“生活方式”。他们已经形成了个人最为根深蒂固，也最恒定的概念，知道能对世界和自身期待些什么。从此以后，世界在他的眼里就被放进了一个固定的统觉[2]框架中。一切经验都得经过解读后才会被接受，而这解读又往往离不开儿童时期形成的对生命意义的原初理解。</p></blockquote><blockquote><p>以爱情与婚姻为例吧。如果我们关心自己的爱人，如果我们能够竭尽所能地令爱人的生活舒适富足，那么自然就会呈现出最好的自己。反之，假如我们认为应该在一个纯粹的环境下发展自我人格，拒绝一切有利于他人的动机，那么只会成为一个嚣张跋扈、令人生厌的家伙。</p></blockquote><blockquote><p><strong>所有真实的“生命的意义”都有一个共同标志，那就是它们都具有普遍意义——能够为众人所分享，为他人所接受。对于生命中种种问题来说，一套切实可行的解决方案同时也是为他人树立的样板范例，因为它提供了一个解决普遍问题的成功之道。即便是最伟大的天才也无法超脱出“卓有建树”这样的评价——只有当一个人的生命被其他人认为是举足轻重的时候，他才有可能被称为“天才”</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《华杉讲透孙子兵法》读书笔记</title>
      <link href="/2018/09/08/%E3%80%8A%E5%8D%8E%E6%9D%89%E8%AE%B2%E9%80%8F%E5%AD%99%E5%AD%90%E5%85%B5%E6%B3%95%E3%80%8B/"/>
      <url>/2018/09/08/%E3%80%8A%E5%8D%8E%E6%9D%89%E8%AE%B2%E9%80%8F%E5%AD%99%E5%AD%90%E5%85%B5%E6%B3%95%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p>这本书借孙子兵法讲现代的公司管理，商战。<br><a id="more"></a></p><h4 id="实力是最厉害的计谋"><a href="#实力是最厉害的计谋" class="headerlink" title="实力是最厉害的计谋"></a>实力是最厉害的计谋</h4><blockquote><p>1、“孙子兵法不是战法，是不战之法；不是战胜之法，是不战而胜之法；不是战而后胜之法，是先胜而后战之法。”<br>2、 “开炮的时候，胜负已定了。”<br>3、“打胜仗的军队，总是先获得胜利地位，获得取胜条件之后，才投入战斗。而打败仗的军队，总是冲上去就打，企图在战斗中捕捉机会侥幸获胜”<br>4、“作战就那一下子，我们99%的工作，都是准备工作。这个道理太深了。人们容易看到的是战利品的多少得失，时间、资源的分配，总是向收割倾斜，不是向准备倾斜。 只问耕耘，不问收获。我看到有的企业家，把收获的工作交给经理人，因为今天的收获都是他三年前耕耘下的。他把他的精力和关注点，投入新的耕耘，为未来作准备”  5、“”这在管理学上叫“沉默的证据”，真正的绝大多数，绝对的大概率事件，都沉默无言，所以你不知道。而那些小概率事件，以少击多居然打赢的，人人都替他大肆宣扬，一千年后你还知道，三千年的例子累积起来，倒显得比比皆是成了主流了。<br>6、“我们经营也是一样，你踏踏实实把产品，把服务做好，别老想着有什么“招”。实际上，奇谋诡道很容易，就那几招，其实技术含量很低，主要技术要点在于演戏要演得像而已。但是“五事七计”技术含量就太高了，全是真功夫，是人格，是智慧，是汗水，是时间，是积累。所以人们爱听三十六计，不爱听“五事七计”。<br>7、“关羽是典型的百战百胜，一败而亡。《孙子兵法》说，真正的善战者，无智名，无勇功，因为善战者不打那么多仗，只打容易的仗，不打跌宕起伏的仗，没有那么多可歌可泣的故事。故事都是讲给老百姓听的，关羽则恰恰和孙子的胜将标准相反，他威名赫赫，在民间是集道德、智慧、武功于一身的千古第一人，而在专业人士看来，关羽实误国之臣也。”<br>8、第二个观念，胜可知而不可为。探查敌我，便知道有没有胜算。如果没有胜算，你想上了战场再强取其胜，那是不可为。因为敌人也是身经百战，不是我们喊几句口号就能打败了。更何况口号人家也没比我们少喊。<br>9、什么叫竞争？竞争的本质是要你没法跟我争</p></blockquote><h1 id="赏罚分明"><a href="#赏罚分明" class="headerlink" title="赏罚分明"></a>赏罚分明</h1><blockquote><p>赏无度，则费而无恩；罚无度，则戮而无威。</p></blockquote><blockquote><p>杜牧注得准确：“信者，使人不惑于刑赏也。”信，就是赏罚分明，每个人都非常清楚，犯什么错受什么刑，立什么功受什么赏。</p></blockquote><blockquote><p>所以“赏其先得者”，就是夺得第一辆战车的士卒。因为先得者，往往是倡谋者。他先发动，大家才跟着一哄而上</p></blockquote><blockquote><p>贾林注解说：“专任智则贼，遍施仁则懦，固守信则愚，恃勇力则暴，令过严则残。五者兼备，各适其用，方可为将帅。”</p></blockquote><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><blockquote><p>绝大部分准备，都是“白准备”，因为准备本来就是“不防一万，只防万一”的，所以每一次有效准备背后，都有九千九百九十九次“白准备”。左史并非料事如神，料定吴军一定会来，他只是按操作规程，做好准备。吴军若不来，士兵们怨声载道，这事过去了，不会写进史书里，我们也不知道。吴军来了，他就名垂青史了。两千多年后我们还能知道这事，可见这样的事是很少发生<br>那开始时下着大雨，楚军列阵等着，吴军不来怎么办？那不白准备了吗？我们经常听见人说：“我白准备了，白浪费了。”这个观念就是兵法要反对的。《兵法百言》：“宁使我有虚防，无使彼得实尝。”宁可我白准备，也不能让他万一来了，让他得手。</p></blockquote><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><blockquote><p>对敌人呢，就像李世民说的，观古今兵法，就一句话：“多方以误之。”想方设法引他失误。</p></blockquote><blockquote><p>兵法都很简单，难的是判断。比如那敌军来，你怎么知道他是来骚扰的，还是来总攻的呢？实际上我们无法知道。所以，毛泽东说：“一上战场，兵法全忘了。”随时有紧急情况要你处理决策，哪顾得上兵法。 怎么办，就要胸中有全局，是你调动敌人，不是敌人调动你。</p></blockquote><blockquote><p>方不上当，不失误，怎么办呢？等待，跟他熬，派间谍，各种布置安排。总之，一定要等到平衡打破，胜算已见，才能出战。</p></blockquote><blockquote><p>夫霸天下者有三戒：毋贪，毋忿，毋急。贪则多失，忿则多难，急则多蹶。夫审大小而图之，乌用贪？衡彼己而施之，乌用忿？酌缓急而布之，乌用急？君能戒此三者，于霸也近矣。”</p></blockquote><blockquote><p>这三件事，背景、形势，都差不多，处理各有参差，结果也不同。所以处大事，决大疑，要熟思是非，不要拘于往事成败，不可迁就一时之利害，更不可归罪于谋臣</p></blockquote><blockquote><p>曾国藩专门说过领导者要独立承担决策责任的问题。因为成败无定，不光是定计的问题。</p></blockquote><blockquote><p>那么，当你认为有几分把握的时候，先自己减去三分一厢情愿分，再想想。 当我们觉得有十分把握的时候，减去三分就是七分。假如我们的判断是准确的，那就有50%的概率获胜，那赢面已经非常大了。</p></blockquote><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><blockquote><p>不能“成功了都是自己伟大，失败了那是环境变化”。环境本来没义务等我，先能避害，然后才可趋利。因为利今天没有，明天还可以再图。而害却可能让我输掉老本，彻底出局。所以避害比趋利重要得多</p></blockquote><blockquote><p>下判断、做事业，要把握两条：趋利、避害。趋利和避害的权重，应该至少是相当的，五十对五十。但是，往往都成了七比三，甚至九比一。为什么，因为利往往在明处，在眼前，让人激动；而害在暗处，在远处，让人心生侥幸。我们经常看到人，去做一些利益极小，而隐患极大的事情。为什么呢？因为那利马上可以得到。而那害，那明明白白的害，他却不可救药地认为“不一定”。</p></blockquote><h3 id="奇兵"><a href="#奇兵" class="headerlink" title="奇兵"></a>奇兵</h3><blockquote><p>曹操注解说：“以五敌一，则三术为正，二术为奇。”如果有敌人并兵自守，不与我战，则有五倍于敌的兵力可攻。怎么攻呢，以三倍兵力为正兵出战，留两倍兵力在手作预备队等待出奇制胜</p></blockquote><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><blockquote><p>中国有句古话叫“不知者不为罪”，大错！不知就是最大的罪！你不知，怎么担当这责任管这事呢？</p></blockquote><blockquote><p>你如何能得到这张王牌呢？就是谁也没看到它的价值的时候，你先占了。那地，一直在那里，就像那牌，一直在那里，谁摸到是谁的，关键你得知道那张牌是王牌</p></blockquote><blockquote><p>不能因为你的队友是猪，你就跟着做猪</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统工程师（软考中级）</title>
      <link href="/2018/09/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%88%E8%BD%AF%E8%80%83%EF%BC%89/"/>
      <url>/2018/09/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%88%E8%BD%AF%E8%80%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>大二下学期考过了软考中级证书。趁自己还记得，写点东西记录一下。<br><a id="more"></a></p><h1 id="写在前面的几句废话"><a href="#写在前面的几句废话" class="headerlink" title="写在前面的几句废话"></a>写在前面的几句废话</h1><p>这个是软考中级证书的一门，含金量还行吧，现在还没在什么招聘要求上看到它。听师兄说国企会在工资考评上算上它，有它能加几百块钱，不知道是不是真的。考它的主要原因是大二上学了数据库原理。大二下学期又比较闲，想以考带学，查漏补缺。<br>简单介绍一下吧。数据库系统工程师资格（水平）考试，一年一次，大概在3 4月份网上报名，5月份考试。考试上午一场，下午一场。两场满分75,45分通过。上午题全是选择题，内容是理论知识，下午5道大题填空或者回答。<br>没考试之前，我对于数据库的学习主要是大二一学期都按习题敲代码。对于增删查改，条件查询，视图、储存过程、触发器的代码比较熟悉。期末考虽然也有理论，但就是死记硬背，没有深入学透。<br>考取这门证书，让我收获许多理论知识。诸如范式、关系代数。还有可怕的计算机专业知识的考查(ಥ_ಥ)比如校验码，补码，磁盘容量计算，流水线，计算机网络。。。<br>敲代码以后可以搬砖。而学习这些理论知识比如范式、关系代数有什么用，我之前也有一些困惑。在知乎上有相似的问题，下面有一些不错的回答。<a href="https://www.zhihu.com/question/273489729" target="_blank" rel="noopener">https://www.zhihu.com/question/273489729</a><br>总之，经过这次考证最初加强数据库理论知识的目的达到了。不过，越学越觉得自己知识漏洞越多。。。</p><h1 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h1><p>这门考试仅仅需要准备两本书，这两本都是考试官方指定用书。<br>《数据库系统工程师2012至2017年试题分析与解答》这本是历年真题有超详细的解析，需认真刷完。<br>《数据库系统工程师考试全程指导》第二本大砖头用于对理论查漏补缺，不买也行，我就没买。by图书馆有的借。</p><h1 id="当时对我有帮助的博文。"><a href="#当时对我有帮助的博文。" class="headerlink" title="当时对我有帮助的博文。"></a>当时对我有帮助的博文。</h1><p>对于三级模式（ 外模式，内模式，模式）刘慰老师的回答让我有种恍然大悟的感觉，推荐阅读！。<br><a href="https://www.zhihu.com/question/38737183/answer/93294527" target="_blank" rel="noopener">https://www.zhihu.com/question/38737183/answer/93294527</a></p><p>列了一些常见的概念 <a href="https://blog.csdn.net/BI_25_RED/article/details/52564110" target="_blank" rel="noopener">https://blog.csdn.net/BI_25_RED/article/details/52564110</a></p><p>我的软考之路 <a href="https://www.cnblogs.com/clnchanpin/p/7358003.html" target="_blank" rel="noopener">https://www.cnblogs.com/clnchanpin/p/7358003.html</a></p><h1 id="我个人做的一小部分笔记"><a href="#我个人做的一小部分笔记" class="headerlink" title="我个人做的一小部分笔记"></a>我个人做的一小部分笔记</h1><h3 id="上午题常见的概念"><a href="#上午题常见的概念" class="headerlink" title="上午题常见的概念"></a>上午题常见的概念</h3><ul><li><p>s读锁（共享） 任何人只能读<br>x写锁（排他） 只有那个人可以读或写</p></li><li><p>并发，就像一个人（cpu）喂2个孩子（程序），轮换着每人喂一口，表面上两个孩子都在吃饭。并行，就是2个人喂2个孩子，两个孩子也同时在吃饭。<br>串行：喂完一个再喂第二个。</p></li><li><p>脏读 修改之后 被别人读到 但这个修改又被撤回作废 别人读到就是脏数据。简单来说就是读到的数据是人家不要的。<br>幻读 一个事务两次查询，第二次比第一次多了或者少了几行几列数据<br>不可重复读 和幻读差不多 不过幻读重点在insert<br>更新丢失 回滚多了</p></li><li><p>undo 撤销 完成之后<br>rollback 未全部完成<br>redo日志 数据修改后的<br>undo日志 数据修改前的</p></li><li><p>集成测试［在概要设计阶段］：接口，通信 黑<br>确认测试［需求设计阶段］：最终用户<br>系统测试<br>恢复测试即容错测试</p></li><li><p>瀑布模型（理想）一个个阶段过，不回头<br>原型（动态定义需求）<br>螺旋模型 结合瀑布和演化并加入风险 小系统一圈一圈走阶段<br>喷泉模型 （迭代）各阶段交叉‼️对风险进行识别和分析</p></li><li><p>标记耦合和控制耦合的区别：标记耦合传递不是简单的变量而是数据结构</p></li><li><p>人耳可听到的范围是20hz-20khz<br>日常说话300-3400hz<br>乐器20hz-20khz</p></li><li><p>共享性是指各结点数据共享。<br>自制性是指每个节点对本地数据都能独立管理。<br>可用性是指当某一场地故障时，系统可以使用其他场地上的副本，而不至于使整个系统瘫痪。<br>分布性是指数据在不同场地上的储存。</p></li><li><p>笛卡尔积 的个数 等于两个个数相乘<br>π投影 垂直 就一个表中只需要姓名和成绩，其他过滤<br>∂选择 水平</p></li><li><p>中继器（转发器） 物理层<br>网桥 数据链路层<br>路由器 网络层<br>网关（协议转换，交换机） 高层<br>集线器 物理层</p></li><li><p>超健：唯一标识（知道学号姓名就可以知道她的年龄班级）<br>候选健：超健基础上，不含多余属性（学号姓名知道一个就行了，但加一个课程名才知成绩）<br>主键：候选健中随意挑一个<br>候选健都是主属性</p></li><li><p>需求分析：数据流图和数据字典。<br>逻辑设计：设计关系模式及相关视图。<br>物理设计：设计数据的物理组织如索引。</p></li><li><p>将所有对象进行分类，然后确定各类的实体，找出属性，这一过程称为聚集。<br>从实体中抽象出子类和父类这一过程称作概括。</p></li><li><p>事物的永久性是指事物一旦提交，其对数据库的影响是永久的，即使系统发生故障也不受影响，提交可以看作是系统对用户的承诺。</p></li></ul><h3 id="说说下午题中一些油腻腻的套路。"><a href="#说说下午题中一些油腻腻的套路。" class="headerlink" title="说说下午题中一些油腻腻的套路。"></a>说说下午题中一些油腻腻的套路。</h3><ul><li><p>第一大题（数据流图）<br>加工的输入数据流和输出数据流要平衡，保证加工的输出数据流都有对应的输入和输出数据流。<br>绘制过程中可能出现的错误：<br>数据黑洞：只进不出<br>数据奇迹：只出不进<br>数据灰洞：加工不出输出流</p></li><li><p>第二大题（sql代码）<br>一个信息点一个信息的标记出来，别漏了。<br>尤其喜欢让你补写GROUP BY。查询了多少个表，group by后面就要跟多少个表。当然函数比如avg（工资）不用。<br>补写where。查询多少个表，where是表数减一条。</p></li><li><p>第三大题（设计实体）<br>实体的关系不止于两个实体。喜欢考三个实体的关系。</p></li><li><p>第四大题（范式）<br>第二范式：消除了非主属性对主属性的部分依赖。缺点是数据冗余，修改、删除、插入异常<br>第三范式：消除了非主属性对主属性的传递依赖。缺点是删除、插入异常。<br>BNF：消除了主属性对码的部分传递函数依赖。</p></li><li><p>第五大题，略。</p></li></ul><div class="aplayer" data-id="30953120" data-server="netease" data-type="song" data-autoplay="true"></div>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博文</title>
      <link href="/2018/09/06/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E6%96%87/"/>
      <url>/2018/09/06/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p><strong><center>我的征途，是星辰大海</center></strong></p><a id="more"></a>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
